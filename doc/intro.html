<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Mozilla/4.76 [en] (X11; U; SunOS 5.8 sun4u) [Netscape]">
</head>
<body background="hierarchy-background.gif">

<center>
<h3>
LISA Project Documentation</h3></center>

<p><br>This page is a haphazard attempt to generate some early documentation
for LISA, in preparation for an alpha release. It is nowhere near comprehensive,
and at some point in the near future will be completely rewritten.
<br>&nbsp;
<h4>
I. What can LISA do right now?</h4>
As of this writing, LISA is capabile of running "smallish" rulesets similar
in composition to the "monkey and bananas" (MAB) planning problem, a version
of which can be found in the project's <i>misc</i> directory. It is possible
to interact with LISA in much the way one interacts with JESS and CLIPS;
there's a fairly decent programming and command language (mentioned later)
that one can use to inspect the knowledge base, fire rules, save facts
to a file, etc. It is <i>not</i> possible, I believe, to build even a small
system suitable for deployment; there are simply too many missing features.
However, one can get a good feel for the environment right now, so I think
in that sense a software release at this point is reasonable.
<br>&nbsp;
<h4>
II. What can't LISA do right now?</h4>
This list is long, but development continues at a pretty good clip. In
no particular order, missing features include but are not limited to:
<ol>
<li>
<i>True reasoning over CLOS objects</i>: Right now LISA performs what I
call "symbolic reasoning". This means that rule patterns (and facts in
the knowledge base) manipulate the equivalent of JESS <i>unordered facts</i>,
or <i>deftemplates</i>. Although each fact name must be backed by a CLOS
class, LISA doesn't do anything with these classes right now. You'll see
how this works in the MAB example.</li>

<br>&nbsp;
<li>
<i>No TEST conditional element</i>.</li>

<br>&nbsp;
<li>
<i>No rule redefinition</i>: LISA doesn't yet support dynamic redefinition
of rules. Before reloading an existing knowledge base one must first CLEAR
the inference engine. Failing to do this will hose the Rete network pretty
good.</li>

<br>&nbsp;
<li>
<i>No multiprocessing support</i>: LISA will eventually support this feature
but the implementation requires some thought.</li>

<br>&nbsp;
<li>
<i>Limited fact slot values</i>: Right now LISA limits the values fact
slots can possess to '(string, number, symbol). In particular, lists are
not yet supported.</li>

<br>&nbsp;
<li>
<i>Patterns like this</i>: LISA currently doesn't support patterns like
(<b>pattern-1 (slot-1 ?var) (slot-2 ?var))</b>, where <b>?var</b> first
occurs in <b>pattern-1</b> and multiple times within its slots. I hope
that's not too vague.</li>

<br>&nbsp;
<li>
<i>No ruleset partitioning</i>: LISA doesn't yet support the notion of
rule "modules" or "packets".</li>

<br>&nbsp;
<li>
<i>No backward chaining</i>: LISA employs a forward-chaining inference
engine. I might support backward-chaining in the future.</li>

<br>&nbsp;
<li>
<i>Mushy language/engine interface</i>: This is a sore point that I intend
to address soon. I really want LISA to have clean separation between the
rule language implementation and the inference engine. In other words,
I'd like to have a "generic" Rete implementation upon which one can attach
different rule programming languages. If you don't like the language that
comes with LISA, write a new one. That sort of thing.</li>

<br>&nbsp;
<li>
<i>No multiple inference engines</i>: LISA supports the existence of multiple
inference engines within the same Lisp world, but there are a couple of
places where I haven't decided just how to manage this. So for now, just
one engine per Lisp world please.</li>

<br>&nbsp;
<li>
<i>Sub-optimal performance</i>: No doubt about it; LISA doesn't yet run
as quickly as she eventually will. I've done a small amount of profiling
to identify some bottlenecks; in particular, slot lookup during pattern
matching is slow, but I've designed a scheme that should allow constant-time
access. This work is actually at the top of my list, just to get it out
of the way.</li>
</ol>

<h4>
III. Getting started.</h4>
LISA <i>requires </i>the Portable Defsystem as maintained by the <a href="http://clocc.sourceforge.net">CLOCC</a>
project; for convenience, a copy is included in the distribution. Building
LISA should be straightforward; load <i>defsys.lisp</i> and evaluate (mk:compile-system
:lisa). Note that currently LISA includes a copy of the CLOCC package PORT;
this will build automatically. If you already have PORT in your Lisp you'll
have to edit <i>defsys.lisp</i> until I find a better way to manage this.
One other thing. LISA uses logical pathnames in her defsystem, and translations
that are suitable for a Linux environment are established there. They might
work for you; perhaps not. Once again, until I figure out how to correctly
place default translations you might have to do some hand editing. Sorry.
<p>To build a knowledge base, write your production rules using the MAB
source as your guide and load the file into Lisp. You can then change to
the :lisa package and experiment. You can find the MAB under the <i>misc</i>
directory in <i>mab.lisp</i>. I realize this is pretty thin; if you have
trouble just <a href="mailto:de.young@computer.org">drop me a line</a>.
I promise the documentation will improve dramatically.
<br>&nbsp;
<h4>
IV. The LISA programming language.</h4>
This section contains brief documentation on LISA's language as it exists
today. Most commands are pretty obvious; none are sufficiently documented.
<ul>
<li>
<i>defrule</i>: Defines a production rule. If you're familiar with CLIPS
or JESS you're in great shape; LISA has her roots in those two systems.
If not you'll have to muddle throught the MAB example for now.</li>

<li>
<i>assert</i>: Asserts a fact into the knowledge base.</li>

<li>
<i>retract</i>: Removes a fact from the knowledge base. You can give <i>retract</i>
either the fact identifier (an integer) or a fact object.</li>

<li>
<i>modify</i>: Modifies a fact. In essence, this function causes a <i>retract</i>
followed by an <i>assert</i>.</li>

<li>
<i>facts</i>: Prints a list of facts.</li>

<li>
<i>agenda</i>: Prints the current rule activations.</li>

<li>
<i>reset</i>: Clears all facts from the knowledge base, resets the inference
engine and asserts the <i>initial fact</i>.</li>

<li>
<i>clear</i>: Re-initializes the inference engine and destroys any existing
Rete network.</li>

<li>
<i>run</i>: Runs the engine until there are no more activations. Optionally
takes as an argument an integer indicating the number of rules to fire
before halting.</li>

<li>
<i>halt</i>. Not yet implemented.</li>

<li>
<i>watch</i>: Asks the engine to indicate the occurrence of certain events.
Currently, one can monitor assertions, retractions, activations and firings;
give <i>watch</i> one of the keywords '(:facts :activations :rules) depending
on what you want to monitor.</li>

<li>
<i>unwatch</i>: Undoes the effect of a previous <i>watch</i>.</li>
</ul>
There's much more to LISA of course; I'll add documentation as I get time.
<br>&nbsp;
<h4>
V. User feedback.</h4>
LISA is immature right now and I am <i>very</i> interested in suggestions
and helpful criticism. In particular, comments related to Lisp constructs
and idioms ("doing things that way is too slow, this approach is better"),
and CLOS/MOP techniques are welcome. But, whatever you can think of that
would make LISA a better system is appropriate.
</body>
</html>
