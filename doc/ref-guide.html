<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Mozilla/4.77 [en] (X11; U; Linux 2.4.2-2 i586) [Netscape]">
</head>
<body background="hierarchy-background.gif">

<center>
<h2>
The LISA Reference Guide</h2></center>
This guide describes in detail the programming interface to LISA. It is
<i>not</i> a treatise on production-rule technology; readers are assumed
to have a working knowledge of rule-based systems and their development.
This document also avoids any detailed description of LISA's implementation
of the Rete algorithm; perhaps at some future date I'll make an attempt.
<br>&nbsp;
<h3>
I. The Programming Language</h3>
This section describes the publicly-available operators in the LISA language,
separated into various categories.
<br>&nbsp;
<h4>
Rule-related Operators</h4>
&nbsp;
<table BORDER WIDTH="100%" NOSAVE >
<tr NOSAVE>
<td NOSAVE>(defrule <i>name (key*) pattern*</i> => <i>action*</i>)</td>

<td NOSAVE>Macro</td>
</tr>
</table>

<blockquote>Creates a rule identified by <i>name</i> and compiles it into
the Rete network. The keyword arguments modify the rule as follows:
<pre>:salience <i>integer</i></pre>

<blockquote>Assigns a priority to the rule that will affect the firing
order. The salience value is a small integer in the range (-250, 250).
By default, all rules have salience 0.</blockquote>

<pre>:module <i>name</i></pre>

<blockquote>Binds the rule to a module identified by the symbol <i>name</i>.
Currently unimplemented.</blockquote>
Each rule consists of zero or more <i>pattern</i>s, or Conditional Elements
(CEs). Collectively these patterns are known as the rule's Left Hand Side
(LHS), and are the entities that participate in the pattern-matching process.
LISA currently defines three pattern types:
<pre>generic pattern</pre>

<blockquote>This pattern type matches against facts in the knowledge base.
The head of the pattern matches equivalently-named facts; the pattern body
is optionally composed of slot-names, values, variables and predicates.
The best way to understand these things is to look at some examples:
<pre>(simple-pattern)</pre>

<blockquote>The simplest type of pattern. This example will match any fact
of class <i>simple-pattern</i>.</blockquote>

<pre>(goal-is-to (action unlock))</pre>

<blockquote>This pattern matches facts of class <i>goal-is-to</i>. In addition,
it specifies that the slot named <i>action</i> must have as its value the
symbol <i>unlock</i>.</blockquote>

<pre>(thing (name ?chest) (on-top-of (not floor)))</pre>

<blockquote>A bit more interesting. Matches facts of class <i>thing</i>;
assuming this is the first appearance of the variable <i>?chest</i>, binds
it to the value of the slot <i>name</i>; specifies that the slot <i>on-top-of</i>
should not have as its value the symbol <i>floor</i>.</blockquote>

<pre>(?monkey (monkey (holding ?chest)))</pre>

<blockquote>Assuming the variable <i>?chest</i> was bound in a previous
pattern, matches facts of class <i>monkey</i> whose slot <i>holding</i>
has the same value as <i>?chest</i>. Additionally, if the pattern is successfully
matched, binds the fact object to the variable <i>?monkey</i>. The variable
<i>?monkey</i> is called a <i>pattern binding</i>.</blockquote>

<pre>(pump (flow-rate ?flow-rate (&lt; ?flow-rate 25)))</pre>

<blockquote>More interesting still. This pattern matches facts of class
<i>pump</i>, and binds the value of the slot <i>flow-rate</i> to the variable
<i>?flow-rate</i>. In addition, there is a constraint on this slot declaring
that the value of <i>?flow-rate</i> must be less than 25. In general, constraints
can be arbitrary Lisp expressions that serve as predicates.</blockquote>

<pre>(fact-with-list (list '(1 2 three)))</pre>

<blockquote>Patterns can perform matching on lists as well as simpler data
types. Here, the slot <i>list</i> must have the value <i>'(1 2 three)</i>.
More complicated list analysis can be done using user-defined predicates.</blockquote>
</blockquote>

<pre>negated pattern</pre>

<blockquote>This pattern type is the complement of most variations of the
generic pattern. Negated patterns have the symbol <i>not</i> as their head,
and match if a fact satisfying the pattern is <i>not</i> found. For example:
<pre>(not (tank-level-warning (tank ?tank) (type low)))</pre>
Note that negated patterns are not allowed to have pattern bindings.</blockquote>

<pre>test pattern</pre>

<blockquote>The <i>test</i> conditional element allows one to evaluate
arbitrary Lisp code on the rule LHS; these Lisp forms serve as a predicate
that determines whether or not the pattern will match. For example, the
pattern
<pre>(test (and (high-p ?tank) (intact-p ?tank)))</pre>
will succeed if the AND form returns non-<i>nil</i>; i.e. the functions
HIGH-P and INTACT-P both return non-<i>nil</i> values.</blockquote>
</blockquote>

</body>
</html>
