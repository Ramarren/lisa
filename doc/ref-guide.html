<!doctype html public "-//w3c//dtd html 4.0 transitional//en">

<html>

<head>

   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">

   <meta name="GENERATOR" content="Microsoft FrontPage 4.0">

</head>

<body background="hierarchy-background.gif">



<center>

<h2>

The LISA Reference Guide</h2></center>

This guide describes in detail the programming interface to LISA. It is

<i>not</i>

a treatise on production-rule technology; readers are assumed to have a

working knowledge of rule-based systems and their development. This document

also avoids any detailed description of LISA's implementation of the Rete

algorithm; perhaps at some future date I'll make an attempt.

<center>

<h2>

Abbreviated Table of Contents</h2></center>

<a href="#The Programming Language">The Programming Language</a>

<br><a href="#The Environment">The Environment</a><br>
<a href="#Contexts">Contexts</a>

<br><a href="#Dynamic Rule Definition">Dynamic Rule Definition</a>

<br><a href="#Queries">Queries</a>

<br><a href="#Conflict Resolution">Conflict Resolution</a><a href="#The LISA Debugger"><br>
The LISA Debugger<br>
</a><a href="auto-notify.html">Auto Notification</a>

<br><a href="#Getting Started">Getting Started</a>

<br><a href="#Things Yet to Do">Things Yet to Do</a>

<br><a href="#Supported Platforms">Supported Platforms</a>

<br>&nbsp;

<h3>

I.&nbsp;<a NAME="The Programming Language"></a>The Programming Language</h3>

This section describes the publicly-available operators in the LISA language,

separated into various categories:

<blockquote><a href="#Fact-Related Operators">Fact-Related Operators</a>

<blockquote>Language elements dealing with facts.</blockquote>

<a href="#Rule-Related Operators">Rule-Related Operators</a>

<blockquote>Language elements dealing with rules.</blockquote>

<a href="#CLOS-Related Operators">CLOS-Related Operators</a>

<blockquote>Language elements dealing with CLOS instances.</blockquote>

<a href="#Engine-Related Operators">Engine-Related Operators</a>

<blockquote>Language elements dealing with operations on an inference engine.</blockquote>

<a href="#Environment-Related Operators">Environment-Related Operators</a>

<blockquote>Language elements dealing with the LISA environment.</blockquote>

<a href="#Debugging-Related Operators">Debugging-Related Operators</a>

<blockquote>Language elements useful during system development.</blockquote>

</blockquote>



<h4>

<a NAME="Fact-Related Operators"></a>Fact-Related Operators</h4>

&nbsp;

<table WIDTH="100%" NOSAVE >

<tr NOSAVE>

<td WIDTH="80%" NOSAVE>(deftemplate <i>name</i> () (<i>slot-name*</i>))</td>



<td>Macro</td>

</tr>

</table>



<blockquote>Creates an internal LISA class identified by <i>name</i> that

can be instantiated as a fact within the knowledge base. The <i>slot-name</i>s

are analogous to class slots, but without any of the keyword arguments.

Templates are a convenient way of specifying concepts that don't need the

full support of CLOS, but frankly they're really only in place to ease the
  transition from CLIPS and Jess.&nbsp;</blockquote>



<table WIDTH="100%" NOSAVE >

<tr NOSAVE>

<td WIDTH="80%" NOSAVE>(defimport <i>class-name</i>)</td>



<td>Macro</td>

</tr>

</table>



<blockquote>A convenience macro that imports the symbols associated with a class
  into whatever LISA-related package the developer wishes. The symbols imported
  reflect the name of the class name and all of its immediate slots. If
  taxonomic reasoning is enabled, then the class's ancestors are imported as
  well.</blockquote>



<table WIDTH="100%" >

<tr>

<td WIDTH="80%">(deffacts <i>deffact-name</i> (<i>key</i>*) <i>fact-list</i>*)</td>



<td>Macro</td>

</tr>

</table>



<blockquote>Registers a list of facts that will be automatically inserted

into the knowledge base upon each RESET. The <i>deffact-name</i> is the

symbolic name that will be attached to this group of facts; <i>fact-list</i>

is a list of fact specifiers. The format of each fact specifier is identical

to that found in an ASSERT form, minus the <i>assert</i> keyword. There

are currently no supported keywords for this macro.</blockquote>



<table WIDTH="100%" NOSAVE >

<tr NOSAVE>

<td WIDTH="80%" NOSAVE>(assert (<i>fact-specifier</i>))</td>



<td>Macro</td>

</tr>

</table>



<blockquote>Inserts a fact identified by <i>fact-specifier</i> into the

knowledge base. There are two forms of ASSERT; the first operates on
  template-based facts, the other on CLOS instances. For templates, ASSERT takes
  a symbol representing the name of the template, followed by a list of (<i>slot-name
  value</i>) pairs:
  <dl>
    <dd>(assert (frodo (name frodo) (age 100))</dd>
  </dl>
  <p>If the template associated with a fact has not been declared prior to its
  assertion, LISA will signal a continuable error.</p>
  <p>For instances of user-defined classes, ASSERT takes a form that must
  evaluate to a CLOS instance:</p>
  <dl>
    <dd>(assert ((make-instance 'frodo :name 'frodo :age 100)))</dd>
  </dl>
  <p>or:</p>
  <dl>
    <dd>(let ((?instance (make-instance 'frodo :name 'frodo)))</dd>
    <dd>&nbsp;&nbsp;&nbsp; (assert (?instance)))</dd>
  </dl>
  <p>or:</p>
  <dl>
    <dd>(defun add-my-instance (frodo-object)<br>
      &nbsp; (assert (#?frodo-object)))</dd>
  </dl>
  <p>This last example makes use of the #? reader macro, which LISA offers as a
  user-customisable feature. It's simply a short-hand notation for <i>(identity
  frodo-object)</i>.</p>
</blockquote>



<table WIDTH="100%" NOSAVE >

<tr NOSAVE>

<td WIDTH="80%" NOSAVE>(retract <i>fact-or-instance</i>)</td>



<td>Function</td>

</tr>

</table>



<blockquote>Removes a fact or instance from the knowledge base. In the case of a
  template-based fact, <i>fact-or-instance</i> may be either a symbol
  representing the name of the fact, or an integer mapping to the fact
  identifier; for CLOS objects <i>fact-or-instance</i> must be an instance of
  STANDARD-OBJECT.</blockquote>



<table WIDTH="100%" NOSAVE >

<tr NOSAVE>

<td WIDTH="80%" NOSAVE>(assert-instance <i>instance</i>)</td>



<td>Function</td>

</tr>

</table>



<blockquote>Inserts a CLOS instance into the knowledge base.</blockquote>



<table WIDTH="100%" NOSAVE >

<tr NOSAVE>

<td WIDTH="80%" NOSAVE>(retract-instance <i>instance</i>)</td>



<td>Function</td>

</tr>

</table>



<blockquote>Removes a CLOS instance from the knowledge base.</blockquote>



<table WIDTH="100%" NOSAVE >

<tr NOSAVE>

<td WIDTH="80%" NOSAVE>(modify <i>fact</i> (<i>slot-name value</i>)*)</td>



<td>Macro</td>

</tr>

</table>



<blockquote>Makes changes to the fact instance identified by <i>fact</i>.

Affected slots and their new values are specified by (<i>slot-name value</i>).

Note that <i>value</i> can be an arbitrary Lisp expression that will be

evaluated at execution time.</blockquote>



<h4>

<a NAME="Rule-Related Operators"></a>Rule-Related Operators</h4>

&nbsp;

<table WIDTH="100%" NOSAVE >

<tr NOSAVE>

<td WIDTH="80%" NOSAVE>(defrule <i>name (key*) pattern*</i> => <i>action*</i>)</td>



<td NOSAVE>Macro</td>

</tr>

</table>



<blockquote>Creates a rule identified by <i>name</i> and compiles it into

the Rete network. <i>Name</i> is any Lisp form that evaluates to a symbol.

The keyword arguments modify the rule as follows:

<pre>:salience <i>integer</i></pre>



<blockquote>Assigns a priority to the rule that will affect the firing

order. The salience value is a small integer in the range (-250, 250).

By default, all rules have salience 0.</blockquote>



<pre>:context <i>name</i></pre>



<blockquote>Binds the rule to a context identified by the symbol <i>name</i>.
  The context must have been previously defined, or LISA will signal an error.</blockquote>

  <pre>:auto-focus <i>t</i></pre>
  <blockquote>
    <p>Identifies the rule as requiring &quot;auto focus&quot; behavior. This
    means that whenever the rule is activated, its context will be made the
    active context after the rule firing completes.</p>
  </blockquote>

If the rule identified by <i>name</i> already exists in the Rete network

it is replaced by the new definition.

<h5>

Patterns</h5>

Each rule consists of zero or more <i>pattern</i>s, or Conditional Elements

(CEs). Collectively these patterns are known as the rule's Left Hand Side

(LHS), and are the entities that participate in the pattern-matching process.

LISA currently defines three pattern types:

<pre>generic pattern</pre>



<blockquote>This pattern type matches against facts in the knowledge base.

The head of the pattern matches equivalently-named facts; the pattern body

is optionally composed of slot-names, values, variables and predicates.

The best way to understand these things is to look at some examples:

<pre>(simple-pattern)</pre>



<blockquote>The simplest type of pattern. This example will match any fact

of class <i>simple-pattern</i>.</blockquote>



<pre>(goal-is-to (action unlock))</pre>



<blockquote>This pattern matches facts of class <i>goal-is-to</i>. In addition,

it specifies that the slot named <i>action</i> must have as its value the

symbol <i>unlock</i>.</blockquote>



<pre>(thing (name ?chest) (on-top-of (not floor)))</pre>



<blockquote>A bit more interesting. Matches facts of class <i>thing</i>;

assuming this is the first appearance of the variable <i>?chest</i>, binds

it to the value of the slot <i>name</i>; specifies that the slot <i>on-top-of</i>

should not have as its value the symbol <i>floor</i>.</blockquote>



<pre>(?monkey (monkey (holding ?chest)))</pre>



<blockquote>Assuming the variable <i>?chest</i> was bound in a previous

pattern, matches facts of class <i>monkey</i> whose slot <i>holding</i>

has the same value as <i>?chest</i>. Additionally, if the pattern is successfully

matched, binds the fact object to the variable <i>?monkey</i>. The variable

<i>?monkey</i>

is called a <i>pattern binding</i>.</blockquote>



<pre>(pump (flow-rate ?flow-rate (&lt; ?flow-rate 25)))</pre>



<blockquote>More interesting still. This pattern matches facts of class

<i>pump</i>,

and binds the value of the slot <i>flow-rate</i> to the variable

<i>?flow-rate</i>.

In addition, there is a constraint on this slot declaring that the value

of <i>?flow-rate</i> must be less than 25. In general, constraints can

be arbitrary Lisp expressions that serve as predicates.</blockquote>



<pre>(fact-with-list (list '(1 2 three)))</pre>



<blockquote>Patterns can perform matching on lists as well as simpler data

types. Here, the slot <i>list</i> must have the value <i>'(1 2 three)</i>.

More complicated list analysis can be done using user-defined predicates.</blockquote>

</blockquote>



<pre>negated pattern</pre>



<blockquote>This pattern type is the complement of most variations of the

generic pattern. Negated patterns have the symbol <i>not</i> as their head,

and match if a fact satisfying the pattern is <i>not</i> found. For example:

<pre>(not (tank-level-warning (tank ?tank) (type low)))</pre>

Note that negated patterns are not allowed to have pattern bindings.</blockquote>



<pre>test pattern</pre>



<blockquote>The <i>test</i> conditional element allows one to evaluate

arbitrary Lisp code on the rule LHS; these Lisp forms serve as a predicate

that determines whether or not the pattern will match. For example, the

pattern

<pre>(test (and (high-p ?tank) (intact-p ?tank)))</pre>

will succeed if the AND form returns non-<i>nil</i>; i.e. the functions

HIGH-P and INTACT-P both return non-<i>nil</i> values.</blockquote>

  <pre>or pattern</pre>
  <blockquote>
    <p>The <i>or</i> conditional element collects any number of patterns into a
    logical group, and matches if any of the patterns inside the <i>or</i>
    match. If more than one of the sub-patterns matches, the <i>or</i> group
    matches more than once. LISA implements a rule containing an <i>or</i> CE as
    a collection of related rules, with each rule representing exactly one
    branch. For example, given the following DEFRULE form:</p>
    <dl>
      <dd>(defrule frodo ()&nbsp;</dd>
      <dd>&nbsp;&nbsp;&nbsp; (frodo)&nbsp;</dd>
      <dd>&nbsp;&nbsp;&nbsp; (or (bilbo)&nbsp;</dd>
      <dd>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (gandalf))&nbsp;</dd>
      <dd>&nbsp;&nbsp;&nbsp; (samwise)</dd>
      <dd>=&gt;)</dd>
    </dl>
    <p>LISA will generate two rules into the rete network, a primary rule and a
    single sub-rule:</p>
    <blockquote>
      <pre>frodo: (frodo), (bilbo), (samwise)</pre>
      <pre>frodo~1: (frodo), (gandalf), (samwise)</pre>
    </blockquote>
    <p>Notice that LISA separates the example DEFRULE into the primary rule <i>frodo</i>,
    and a single sub-rule, <i>frodo~1</i>. LISA maintains the relationship
    between a primary rule and its sub-rules; if a primary rule is removed,
    every related sub-rule is also eliminated.</p>
  </blockquote>

    <pre>logical pattern</pre>
  <blockquote>
    <p>The <i>logical</i> conditional element implements LISA's notion of truth
    maintenance. Patterns appearing within a LOGICAL form in a rule are
    conditionally bound to facts asserted from that rule's RHS. If during
    inferencing one or more logical facts are retracted (or asserted in the case
    of negated patterns), all facts bound to
    those logical facts are retracted. Here's an example:</p>
    <dl>
      <dd>(defrule frodo ()</dd>
      <dd>&nbsp;&nbsp;&nbsp; (logical&nbsp;</dd>
      <dd>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (bilbo)&nbsp;</dd>
      <dd>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(not (gandalf)))</dd>
      <dt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        (frodo)</dt>
      <dd>=&gt;</dd>
      <dd>(assert (pippin)))</dd>
    </dl>
    <p>When rule FRODO fires, it asserts a PIPPIN fact that is dependent on the
    existence of BILBO and the absence of GANDALF. If either BILBO is retracted or GANDALF
    asserted, PIPPIN will be removed as a consequence.</p>
    <p>A LOGICAL conditional element must be the first pattern in a rule.
    Multiple LOGICAL forms within the same rule are allowed, but they must be
    contiguous.</p>
    <p><b>NB</b>: A rule beginning with the LOGICAL conditional element
    implicitly matches the INITIAL-FACT; thus, in order for rules employing
    truth maintenance to function correctly, a RESET must be always be performed
    prior to any operation affecting working memory. LISA's behavior is
    undefined otherwise.</p>
  </blockquote>

    <pre>exists pattern</pre>
  <blockquote>
    <p>The EXISTS conditional element performs an existential test on a pattern.
    The pattern will match exactly once, even if there are many facts that might
    satisfy it. For example, this rule:</p>
    <dl>
      <dd>
    <p>(defrule frodo ()<br>
    &nbsp;&nbsp;&nbsp; (exists (frodo (has-ring t)))<br>
    &nbsp;&nbsp;&nbsp; =&gt;)</p>
      </dd>
    </dl>
    <p>will activate just once if there is at least one FRODO fact whose
    HAS-RING slot has the value T.</p>
  </blockquote>
  <pre>The initial fact</pre>
  <p>If a rule provides no conditional elements, then it is said to match the

<i>initial-fact</i>,

which is asserted as the result of a call to <i>reset</i>. Thus, the following

rule will always activate after each reset:</p>

<dl>

<dd>

(defrule always-fires ()</dd>



<dd>

&nbsp;&nbsp; =></dd>



<dd>

&nbsp;&nbsp; (format t "always-fires fired!~%"))</dd>



  </dl>

  <pre>CLOS instances</pre>

<p>Every fact asserted into working memory is backed by a corresponding CLOS
instance. In the case of DEFTEMPLATEs, LISA creates an internal class mirroring
the template; user-defined class instances are simply bound to a fact during
assertions. Instances associated with facts are accessible on rule LHSs via the
:OBJECT special slot:

<dl>

<dd>

(tank (name ?name) (:object&nbsp; ?tank-object))</dd>



  </dl>



<p>Once bound, method and function calls can be made on this object from

the rule's LHS and RHS.

<dl>

<p>When reasoning over CLOS objects, LISA is capable of considering an

instance's object hierarchy during pattern matching. In other words, it

is possible to write rules that apply to many facts that share a common

ancestry. The following code fragment provides an example:

<br>&nbsp;

<dd>

(defclass fundamental () ())</dd>



<dd>

(defclass rocky (fundamental) ())</dd>



<dd>

(defclass boris (fundamental) ())</dd>



<dt>&nbsp;</dt>
&nbsp;

<dd>

(defrule cleanup (:salience -100)</dd>



<dd>

&nbsp;&nbsp;&nbsp; (?fact (fundamental))</dd>



<dd>

&nbsp;&nbsp;&nbsp;&nbsp; =></dd>



<dd>

&nbsp;&nbsp;&nbsp; (retract ?fact))</dd>



<dt>&nbsp;</dt>

<p>The rule <i>cleanup</i> will fire for every instance of <i>rocky</i>

and <i>boris</i> in the knowledge base, retracting each in turn. Note that
taxonomic reasoning is disabled by default. To use the feature, evaluate (setf
(lisa:consider-taxonomy) t).</dl>

</blockquote>



<blockquote>

<h5>

Actions</h5>

Following any conditional elements are the rule's actions, if any. Collectively

known as the Right Hand Side (RHS), actions consist of arbitrary Lisp forms. All variables declared on the LHS are available, along with the special

operator <i>engine</i>, which evaluates to the rule's inference engine

object. Currently, each rule's RHS is given to the Lisp compiler during

rule compilation, and executes within a special lexical environment established

by LISA for each firing.</blockquote>



<table BORDER=0 WIDTH="100%" >

<tr>

<td WIDTH="80%">(undefrule <i>rule-name</i>)</td>



<td>Macro</td>

</tr>

</table>



<blockquote>Undefines, or removes, a rule from the Rete network. <i>Rule-name</i>
  is a symbol representing the name of the rule. If <i>rule-name</i> is not
  qualified with a context name (e.g. <i>context.rulename</i>), then the Initial
  Context is assumed.</blockquote>



<h4>

<a NAME="CLOS-Related Operators"></a>CLOS-Related Operators</h4>

There are a few special features that LISA provides for keeping CLOS instances
synchronised with their corresponding facts in working memory. If an instance is
altered outside of LISA's control, then LISA must somehow be informed of the
change to maintain working memory consistency. The basic mechanism is manual
notification, in which an application explicitly invokes a special function to
initiate synchronisation. Users of the two commercial Lisps supported by LISA
also have the option of employing <a href="auto-notify.html">Auto Notification</a>,
an experimental feature that removes the burden of synchronisation from the
application.

<br>&nbsp;



<table WIDTH="100%" NOSAVE >

<tr NOSAVE>

<td WIDTH="80%" NOSAVE>(mark-instance-as-changed <i>instance </i>&amp;key <i>slot-name</i>)</td>



<td>Function</td>

</tr>

</table>



<blockquote>Notifies LISA that a change has been made to <i>instance</i>

outside of the knowledge-base (i.e. not via the <i>modify</i> operator),

and synchronizes the instance with its associated fact. <i>Slot-name</i> is
  either the symbolic name of a slot belonging to <i>instance</i> that has
  changed value, or NIL (the default), in which case all slots are synchronized.
  An application <i>must</i> call this method whenever a slot change occurs

outside of LISA's control.</blockquote>



<h4>

<a NAME="Engine-Related Operators"></a>Engine-Related Operators</h4>

These operators provide an interface to instances of the inference engine

itself.<br>
<table border="0" width="100%">
  <tr>
    <td width="80%">(inference-engine)</td>
    <td width="20%">Function</td>
  </tr>
</table>
<blockquote>
  <p>Evaluates to the currently active instance of the inference engine.</p>
</blockquote>

<table WIDTH="100%" NOSAVE >

<tr NOSAVE>

<td WIDTH="80%" NOSAVE>(reset)</td>



<td>Function</td>

</tr>

</table>



<blockquote>Re-initializes the knowledge base, removing

facts, clearing all context agendas, and asserting the <i>initial-fact</i>.</blockquote>



<table WIDTH="100%" NOSAVE >

<tr NOSAVE>

<td WIDTH="80%" NOSAVE>(clear)</td>



<td>Function</td>

</tr>

</table>



<blockquote>Re-initializes the LISA environment, mostly by creating a
  new instance of the default inference engine.</blockquote>



<table WIDTH="100%" NOSAVE >

<tr NOSAVE>

<td WIDTH="80%" NOSAVE>(run &amp;optional <i>focus-list)</i></td>



<td>Function</td>

</tr>

</table>



<blockquote>Runs the inference engine, optionally pushing the context names on <i>focus-list</i>
  onto the focus stack before doing so. Execution

will continue until either all agendas are exhausted or a rule calls (halt).</blockquote>



<table WIDTH="100%" NOSAVE >

<tr NOSAVE>

<td WIDTH="80%" NOSAVE>(walk &amp;optional <i>step</i>)</td>



<td>Function</td>

</tr>

</table>



<blockquote>Runs the engine in <i>step</i> increments, single-stepping

by default. Here, "single-stepping" means "one rule at a time".</blockquote>



<table WIDTH="100%" NOSAVE >

<tr NOSAVE>

<td WIDTH="80%" NOSAVE>(halt)</td>



<td>Function</td>

</tr>

</table>



<blockquote>Halts the inference engine, even if the agendas

still have activations. Typically used only on rule RHSs.</blockquote>



<h4>

<a NAME="Environment-Related Operators"></a>Environment-Related Operators</h4>



<blockquote>These operators are used to manipulate and inspect the LISA
  environment.</blockquote>



<table WIDTH="100%" NOSAVE >

<tr NOSAVE>

<td WIDTH="80%" NOSAVE>(with-inference-engine (<i>engine</i>) <i>forms</i>*)</td>



<td>Macro</td>

</tr>

</table>



<blockquote>Evaluates <i>forms</i> within the context of the inference

engine <i>engine</i>. Under most circumstances, use this macro in a multi-processing

environment to safely load a knowledge base into <i>engine</i>.</blockquote>



<table BORDER=0 WIDTH="100%" NOSAVE >

<tr NOSAVE>

<td WIDTH="80%" NOSAVE>(make-inference-engine)</td>



<td>Function</td>

</tr>

</table>



<blockquote>Creates an instance of LISA's default inference engine.</blockquote>



<table BORDER=0 WIDTH="100%" >

<tr>

<td WIDTH="80%">(rule)</td>



<td>Function</td>

</tr>

</table>



<blockquote>Within the context of an executing rule, returns the CLOS object

representing that rule.</blockquote>



<table border="0" width="100%">
  <tr>
    <td width="80%">(consider-taxonomy)</td>
    <td width="20%">Function</td>
  </tr>
</table>
<blockquote>



<p>

Returns the current setting for taxonomic reasoning. Use (setf
(consider-taxonomy) <i>value</i>) to change the setting. The default (NIL) means
LISA ignores class taxonomy during pattern matching.</p>

</blockquote>



<table border="0" width="100%">
  <tr>
    <td width="80%">(allow-duplicate-facts)</td>
    <td width="20%">Function</td>
  </tr>
</table>
<blockquote>



<p>

Returns the current setting for duplicate fact checking. Use (setf
(allow-duplicate-facts) <i>value</i>) to change the setting. By default, LISA
allows duplicate facts to be asserted. If checking is enabled and an application
attempts to assert a duplicate fact, LISA signals a DUPLICATE-FACT error.</p>

</blockquote>



<table border="0" width="100%">
  <tr>
    <td width="80%">(use-fancy-assert)</td>
    <td width="20%">Function</td>
  </tr>
</table>
<blockquote>



<p>

Returns the current setting for fancy assertions. If enabled (the default), the
#? reader macro is installed in the global readtable.</p>

</blockquote>



<h4>

<a NAME="Debugging-Related Operators"></a>Debugging-Related Operators</h4>

These operators are typically used interactively to inspect the state of

an inference engine. Some of these operators are only loosly defined and

need further work.

<br>&nbsp;

<table WIDTH="100%" NOSAVE >

<tr NOSAVE>

<td WIDTH="80%" NOSAVE>(facts)</td>



<td>Function</td>

</tr>

</table>



<blockquote>Prints on <i>trace output</i> the contents of the active
  inference engine's fact base.</blockquote>



<table WIDTH="100%" NOSAVE >

<tr NOSAVE>

<td WIDTH="80%" NOSAVE>(rules &amp;optional <i>context-name</i>)</td>



<td>Function</td>

</tr>

</table>



<blockquote>Prints on <i>trace output</i> the contents of the active
  inference engine's rule base. By default, all rules and all contexts will be
  printed. If <i>context-name</i> is provided, then only those rules in that
  context are printed.</blockquote>



<table WIDTH="100%" NOSAVE >

<tr NOSAVE>

<td WIDTH="80%" NOSAVE>(agenda &amp;optional <i>context-name</i>)</td>



<td>Function</td>

</tr>

</table>



<blockquote>Prints on <i>trace output</i> the contents of the active
  inference engine's agenda. By default, the agendas for all contexts will be
  printed, unless <i>context-name</i> is supplied.</blockquote>



<table WIDTH="100%" NOSAVE >

<tr NOSAVE>

<td WIDTH="80%" NOSAVE>(watch <i>event</i>)</td>



<td>Function</td>

</tr>

</table>



<blockquote>Asks LISA to report the occurrence of <i>event</i> to <i>trace output</i>.

<p>Currently, LISA allows monitoring of these events:

<pre>:facts</pre>



<blockquote>Triggers an event each time a fact is asserted or retracted.</blockquote>



<pre>:activations</pre>



<blockquote>Triggers an event each time a rule is added to or removed from

the agenda.</blockquote>



<pre>:rules</pre>



<blockquote>Triggers an event each time a rule is fired.</blockquote>

  <pre>:all</pre>
  <blockquote>
    <p>Watch all allowable events.</p>
  </blockquote>

</blockquote>



<table WIDTH="100%" NOSAVE >

<tr NOSAVE>

<td WIDTH="80%" NOSAVE>(unwatch <i>event</i>)</td>



<td>Function</td>

</tr>

</table>



<blockquote>Disables the monitoring of <i>event</i>. See the documentation

for <i>watch</i> to see the allowable event types.</blockquote>



<table WIDTH="100%" NOSAVE >

<tr NOSAVE>

<td WIDTH="80%" NOSAVE>(watching)</td>



<td>Function</td>

</tr>

</table>



<blockquote>Displays the list of events currently being monitored.</blockquote>



<h3>

II.&nbsp;<a NAME="The Environment"></a>The Environment</h3>

For application developers, LISA makes available two different types of

environments. Package LISA-USER contains all of LISA's exported symbols, plus

those of COMMON-LISP. User-level work can safely be done in this package.

Alternatively, package LISA-LISP can be used with DEFPACKAGE forms to import a

LISA environment into user-defined packages:

<blockquote>

  <p>(defpackage &quot;FRODO&quot;<br>

  &nbsp; (:use &quot;LISA-LISP&quot;))</p>

</blockquote>

<p>As with LISA-USER, LISA-LISP exports all external symbols in the LISA and

COMMON-LISP packages. See the

various examples provided in "lisa:misc;".</p>

<p>There are a few aspects of LISA that may be customised prior to building. The
file &quot;lisa:src;config;config.lisp&quot; contains a set of default
behaviors; feel free to edit this file to your liking.</p>

<h3>

III. <a name="Contexts">Contexts</a></h3>

<p>

LISA contexts are a way of partitioning a knowledge base into distinct groups of
rules. The mechanism is similar to modules in CLIPS and recent versions of Jess,
in that individual rule groups can be invoked &quot;procedurally&quot; without
resorting to the use of control facts to manipulate firing order. Contexts can
also serve as an organizational construct when working with larger knowledge
bases. Each context has its own agenda and conflict resolution strategy.</p>

<p>

Each inference engine instance created in LISA contains a default context, named
&quot;The Initial Context&quot; (or INITIAL-CONTEXT). Unless arrangements are
made otherwise, all rules will reside in this context.&nbsp; The DEFCONTEXT
macro creates a new context; rules may then be loaded into the new context by
supplying the :CONTEXT keyword to DEFRULE. Contexts serve as a form of namespace
for rules; thus, it is legal for identically named rules to reside in different
contexts. Rules are distinctly identified by qualifying the rule name with the
context name; for example, rule <i>wizards.gandalf</i> is a rule named <i>gandalf</i>
that resides within the <i>wizards</i> context.</p>

<p>

Activations in the Initial Context are always available for firing. Otherwise,
activations in other contexts will only fire if those contexts are explicitly
given control, via the FOCUS operator. Each inference engine maintains its own
focus stack; before a new context is given control, the active context is pushed
onto the focus stack. The REFOCUS operator may be used on a rule's RHS (or,
perhaps, interactively) to leave
the active context and return control to the previous context on the stack.
Control automatically returns to the previous context if the active context runs
out of activations. When all contexts have exhausted their activations, the
inference engine halts.</p>

<p>

A rule can be tagged with the <i>auto-focus</i> attribute by supplying the
AUTO-FOCUS keyword to DEFRULE. If an auto-focus rule activates, that rule's
context is automatically pushed onto the focus stack and given control when the
rule completes its firing.</p>

<p>Note carefully that while the <i>rules</i> in a knowledge base may be
partitioned, there remains a <i>single working memory</i> per inference engine.
At any given time, all facts in a knowledge base are visible to all rules in
that knowledge base, regardless of context.</p>

<table border="0" width="100%">
  <tr>
    <td width="80%">(defcontext <i>context-name</i> &amp;key <i>strategy</i>)</td>
    <td width="20%">Macro</td>
  </tr>
</table>
<blockquote>
  <p>Creates a new context identified by <i>context-name</i>, which must be a
  string designator. If <i>strategy</i> is non-NIL then it must be an object
  implementing a suitable conflict resolution strategy.</p>

</blockquote>
<table border="0" width="100%">
  <tr>
    <td width="80%">(undefcontext <i>context-name</i>)</td>
    <td width="20%">Macro</td>
  </tr>
</table>
<blockquote>
  <p>Destroys the context identified by <i>context-name</i>, which must be a
  string designator. All rules bound to the context are removed from the Rete
  network, along with their activations, if any.</p>

</blockquote>
<table border="0" width="100%">
  <tr>
    <td width="80%">(focus &amp;rest <i>context-names</i>)</td>
    <td width="20%">Macro</td>
  </tr>
</table>
<blockquote>

<p>

If <i>context-names</i> is non-NIL, it should be a collection of context names
that will be added to the focus stack. Contexts are pushed onto the focus stack
in right-to-left order. If no names are specified, then FOCUS
returns the active context object.</p>

</blockquote>
<table border="0" width="100%">
  <tr>
    <td width="80%">(refocus)</td>
    <td width="20%">Macro</td>
  </tr>
</table>
<blockquote>

<p>

Activates the next available context.</p>

</blockquote>
<table border="0" width="100%">
  <tr>
    <td width="80%">(focus-stack)</td>
    <td width="20%">Macro</td>
  </tr>
</table>
<blockquote>

<p>

Returns the inference engine's focus stack.</p>

</blockquote>
<table border="0" width="100%">
  <tr>
    <td width="80%">(contexts)</td>
    <td width="20%">Macro</td>
  </tr>
</table>
<blockquote>

<p>

Returns a list of all the inference engine's defined contexts.</p>

</blockquote>

<table border="0" width="100%">
  <tr>
    <td width="80%">(with-context (<i>context</i> &amp;body <i>body</i>)</td>
    <td width="20%">Macro</td>
  </tr>
</table>
<blockquote>

<p>

Evaluates the forms contained in <i>body</i> within the context <i>context</i>.</p>

</blockquote>

<h3>

IV.&nbsp;<a NAME="Dynamic Rule Definition"></a>Dynamic Rule Definition</h3>

In addition to statically declared rules, LISA supports the definition

of rules at runtime. That is, it is possible to create new rules from the

RHSs of existing rules as they fire. These <i>dynamically defined</i> rules

become immediately available to the inference engine for potential activation.

As a simple example, consider the following rule:<br>

<blockquote>(defrule rocky ()

<br>&nbsp; (rocky (name ?name))

<br>&nbsp; =>

<br>&nbsp; (defrule boris ()

<br>&nbsp;&nbsp;&nbsp; (boris (name ?name))

<br>&nbsp;&nbsp;&nbsp; =>

<br>&nbsp;&nbsp;&nbsp; (format t "Dynamic rule BORIS fired; NAME is ~S~%"

?name)))</blockquote>

When rule ROCKY fires, its RHS creates a dynamically defined rule named

BORIS. This new rule is inserted into the inference engine and immediately

becomes part of the Rete network. Variables bound on the LHS of ROCKY behave

as expected within the context of BORIS; this means that ?NAME in BORIS

is bound to the same object as that found in ROCKY<sup>*</sup>.

<p>Here's a more complicated example:

<blockquote>(defrule rocky ()

<br>&nbsp; (rocky (name ?name))

<br>&nbsp; =>

<br>&nbsp; (let ((dynamic-rule

<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

(defrule (gensym) ()

<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

(boris (name ?name))

<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

=>

<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

(format t "Dynamic rule ~A fired; name is ~S~%" (get-name (rule)) ?name))))

<br>&nbsp;&nbsp;&nbsp; (format t "Rule ROCKY added dynamic rule ~A~%" (get-name

dynamic-rule))))</blockquote>

As before, rule ROCKY creates a dynamic rule when fired. However, this

time the new rule is given a unique name by evaluating the form (GENSYM);

either the name or the instance can then be remembered for use later. These

two rules also introduce functions in the LISA API for retrieving both

the currently executing rule and its name (RULE and GET-NAME, respectively).

<p><sup>*</sup> Actually, this isn't precisely true. Whenever LISA encounters

a dynamic rule during parsing it looks at all the rule's variables and

substitutes any bound values. Thus, in rule BORIS the variable ?NAME would

be replaced by the value of ?NAME as bound in rule ROCKY.

<h3>

V.&nbsp;<a NAME="Queries"></a>Queries</h3>

As of LISA version 1.2, a simple query language is supported that allows

retrieval of facts from a knowledge base, either interactively via a Lisp

listener or programmatically. The query engine leverages the inferencing

component by transforming query expressions into rules and inserting them,

at runtime, into the Rete network. Each query is assigned a unique identifier

and cached upon first appearance; subsequent queries with semantically

equivalent bodies will find the cached instance and execute with substantially

improved performance, especially for larger knowledge bases. As an example,

consider the following two query forms:

<p>&nbsp; (retrieve (?x ?y)

<br>&nbsp;&nbsp;&nbsp; (?x (hobbit (name ?name)))

<br>&nbsp;&nbsp;&nbsp; (?y (ring-bearer (name ?name))))

<p>&nbsp; (retrieve (?h1 ?h2)

<br>&nbsp;&nbsp;&nbsp; (?h1 (hobbit (name ?hobbit-name)))

<br>&nbsp;&nbsp;&nbsp; (?h2 (ring-bearer (name ?hobbit-name))))

<p>The variables appearing in the first argument to RETRIEVE (e.g. '(?x

?y)) are used to establish bindings for each firing of the query; each

variable must also appear in the query body as an appropriate pattern binding.

Other than this requirement, query bodies are structurally identical to

rule bodies; anything that is legal in a rule LHS is legal in a query body.

Note that these two examples are semantically equivalent; although the

variable names are different, the patterns appear in the same order and

the relationships among variables are identical. Thus, firing either query

will yield the same set of fact bindings. LISA is able to recognize such

similarities in queries and implements a caching scheme that minimizes

unnecessary dynamic rule creation.

<p>RETRIEVE returns two values; a list of bindings for each query firing,

and the symbolic name assigned by LISA to the query instance. The second

value is probably only useful while developing/testing queries; using this

symbol one can ask LISA to forget about a query by removing it from the

cache and the Rete network. The binding list is the principal value of

interest. Since a query is really a rule, it can fire an arbitrary number

of times for each invocation. Each firing is represented as a list of CONS

cells. The CAR of each cell is one of the variables specified in the query's

binding list; its CDR is a fact bound to that variable that satisfies the

variable's associated pattern. For example, assuming that the first of

the above query examples fires twice during a certain invocation, RETRIEVE

would return something like:

<p>&nbsp; (((?X . &lt;HOBBIT INSTANCE 1>) (?Y . &lt;RING-BEARER INSTANCE

1>))

<br>&nbsp;&nbsp;&nbsp; ((?X . &lt;HOBBIT INSTANCE 2>) (?Y . &lt;RING-BEARER

INSTANCE 2)))

<br>&nbsp; #:G7777

<p>As explained previously, the second value is the symbolic name LISA

assigned to the query when its rule instance was initially created. Most

of the time it will be ignored.

<p>As of release 1.3, LISA incorporates a unified view of template- and

CLOS-based facts; as a result queries now function for both types of facts. In

the former case, LISA creates a class modeled around the template. Class and

slot names are taken directly from the DEFTEMPLATE form; each slot is given a

reader method named according to DEFSTRUCT conventions (i.e. <i>class name-slot

name</i>). For example,&nbsp;

<blockquote>

  <p>(deftemplate frodo ()<br>

  &nbsp; (slot companion (default merry)))

</blockquote>

<p>Will yield the following class specification:

<blockquote>

  <p>(defclass frodo (inference-engine-object)<br>

  &nbsp; ((companion :initform 'merry :initarg :companion :reader

  frodo-companion)))

</blockquote>

<p>These functions and macros comprise the current interface to the query

engine:

<br>&nbsp;

<table COLS=2 WIDTH="100%" >

<tr>

<td WIDTH="80%">(retrieve (<i>variables</i>*) <i>patterns</i>*)</td>



<td>Macro</td>

</tr>

</table>



<blockquote>Initiates a query against the knowledge base. Variable bindings

for the query are found in <i>variables; patterns</i> consists of matching

forms that comprise the body of the query rule. RETRIEVE returns two values:

a list of CONS cells for each firing and the symbolic name LISA assigned

to the query when it was initially constructed. The CAR of each CONS cell

is one of the binding variables; the CDR is the CLOS instance bound to

that variable.</blockquote>



<table COLS=2 WIDTH="100%" NOSAVE >

<tr NOSAVE>

<td WIDTH="80%" NOSAVE>(forget-query <i>name</i>)</td>



<td>Function</td>

</tr>

</table>



<blockquote>Instructs LISA to forget about the query identified by the

symbol <i>name</i>. Doing so removes the query's rule instance from the

Rete network and the query itself from the cache. Useful only during query

development, probably.</blockquote>



<table border="0" width="100%">

  <tr>

    <td width="80%">(with-simple-query ((<i>var value</i>) <i>query-form</i>

      &amp;body <i>body</i>))</td>

    <td width="20%">Macro</td>

  </tr>

</table>

<blockquote>

  <p>Evaluates <i>query-form</i>. Then, iterates over the resulting list

  structure, binding each variable and fact to <i>var</i> and <i>value</i>,

  respectively, and evaluating <i>body</i>. This macro is useful if one is

  interested in just the individual variable/fact pairs and doesn't care much

  about the binding context that occurred during query firing.</p>

</blockquote>



<h3>

VI.&nbsp;<a NAME="Conflict Resolution"></a>Conflict Resolution</h3>

Conflict Resolution (CR) is the mechanism LISA employs to determine the

order in which multiple activations will fire. Currently, LISA offers two

"built-in" strategies; <i>breadth-first</i> and <i>depth-first</i>. It

is possible to implement new CR algorithms by creating a class derived

from <i>lisa:strategy</i> and implementing a few generic functions; instances

of this new strategy can then be given to <i>make-inference-engine</i>.

<br>&nbsp;

<table WIDTH="100%" NOSAVE >

<tr NOSAVE>

<td WIDTH="80%" NOSAVE>(add-activation <i>strategy</i> <i>activation</i>)</td>



<td>Generic Function</td>

</tr>

</table>



<blockquote>Makes a new <i>activation</i> eligible for firing.</blockquote>



<table WIDTH="100%" NOSAVE >

<tr NOSAVE>

<td WIDTH="80%" NOSAVE>(find-activation <i>strategy</i> <i>rule</i> <i>token</i>)</td>



<td>Generic Function</td>

</tr>

</table>



<blockquote>Locates an activation associated with <i>rule</i> and <i>token</i>.</blockquote>



<table WIDTH="100%" NOSAVE >

<tr NOSAVE>

<td WIDTH="80%" NOSAVE>(next-activation <i>strategy</i>)</td>



<td>Generic Function</td>

</tr>

</table>



<blockquote>Returns the next eligible activation.</blockquote>



<table WIDTH="100%" NOSAVE >

<tr NOSAVE>

<td WIDTH="80%" NOSAVE>(list-activations <i>strategy</i>)</td>



<td>Generic Function</td>

</tr>

</table>



<blockquote>Returns a list of eligible activations.</blockquote>

Documentation for the CR interface is still fairly light. Look for improvements

in upcoming releases.
<h3>VII. <a name="The LISA Debugger">The LISA Debugger</a></h3>
<p>New as of 2.0 alpha 4, the LISA debugger is a simple monitoring and
inspection utility that may be used to &quot;debug&quot; production rules.
Although one cannot step through a rule pattern by pattern, breakpoints may be
set to trigger just before a rule fires. When a breakpoint is reached, one can
then interactively examine the token stack, display all pattern bindings and
their values, single-step into the next activation, etc.</p>
<p>By default, LISA builds without the debugger loaded to avoid a slight
performance drag on rule firings. To use the debugger, in the CL-USER package
evaluate the form (require 'lisa-debugger (lisa-debugger)). If you're running
Allegro Common Lisp, LISA understands how to hook into the module search list;
thus you may instead evaluate (require 'lisa-debugger).</p>
<p>The functionality available via the LISA debugger may increase as user needs
dictate; here is the command set as of this writing:</p>
<table border="0" width="100%">
  <tr>
    <td width="80%">(set-break <i>rule-name</i>)</td>
    <td width="20%">Function</td>
  </tr>
</table>
<blockquote>

<p>

Sets a breakpoint in the rule identified by the symbol <i>rule-name.</i></p>

</blockquote>
<table border="0" width="100%">
  <tr>
    <td width="80%">(clear-break <i>rule-name</i>)</td>
    <td width="20%">Function</td>
  </tr>
</table>
<blockquote>
  <p>Clears the breakpoint previously set on the rule identified by the symbol <i>rule-name</i>.</p>

</blockquote>
<table border="0" width="100%">
  <tr>
    <td width="80%">(clear-breaks)</td>
    <td width="20%">Function</td>
  </tr>
</table>
<blockquote>
  <p>Removes all breakpoints.</p>

</blockquote>
<table border="0" width="100%">
  <tr>
    <td width="80%">*break-on-subrules*</td>
    <td width="20%">Special variable</td>
  </tr>
</table>
<blockquote>
  <p>Setting this variable to a non-NIL value will cause the debugger to manage
  breakpoints for a primary rule and all of its subrules (see the section on the
  <i>or</i> conditional element for an explanation of primary rules).</p>

</blockquote>
<table border="0" width="100%">
  <tr>
    <td width="80%">(next)</td>
    <td width="20%">Function</td>
  </tr>
</table>
<blockquote>
  <p>Fires the currently suspended rule, then single-steps into the next
  activation, if there is one. If there isn't one, the debugger exits.</p>

</blockquote>
<table border="0" width="100%">
  <tr>
    <td width="80%">(resume)</td>
    <td width="20%">Function</td>
  </tr>
</table>
<blockquote>
  <p>Resumes normal execution, until the next breakpoint is reached.</p>

</blockquote>
<table border="0" width="100%">
  <tr>
    <td width="80%">(tokens &amp;key (<i>verbose nil</i>))</td>
    <td width="20%">Function</td>
  </tr>
</table>
<blockquote>
  <p>&nbsp;Displays the token stack, which contains the facts that activated
  this particular rule. If <i>verbose</i> is non-nil, then the fact instances
  themselves are printed; otherwise, a shorthand notation is used.</p>

</blockquote>
<table border="0" width="100%">
  <tr>
    <td width="80%">(bindings)</td>
    <td width="20%">Function</td>
  </tr>
</table>
<blockquote>
  <p>Displays the bindings (pattern variables) found on the rule's LHS, along
  with their values.</p>

</blockquote>
<table border="0" width="100%">
  <tr>
    <td width="80%">(fact <i>fact-id</i>)</td>
    <td width="20%">Function</td>
  </tr>
</table>
<blockquote>
  <p>Returns the fact instance associated with <i>fact-id</i>, a small integer
  assigned to each fact by the inference engine.</p>

</blockquote>
<table border="0" width="100%">
  <tr>
    <td width="80%">(breakpoints)</td>
    <td width="20%">Function</td>
  </tr>
</table>
<blockquote>
  <p>Displays all breakpoints.</p>

</blockquote>
<table border="0" width="100%">
  <tr>
    <td width="80%">(rule)</td>
    <td width="20%">Function</td>
  </tr>
</table>
<blockquote>
  <p>Returns the rule instance representing the suspended activation.</p>

</blockquote>

<h3>

VIII.&nbsp;<a NAME="Getting Started"></a>Getting Started</h3>

LISA requires the Portable Defsystem as maintained by the CLOCC project;

for your convenience, a copy is included in the distribution. Building

LISA should be straight-forward. First, either load
&quot;lisa:lisa.system&quot;

or change your working directory to the LISA root directory; then, evaluate (mk:compile-system
:lisa). Note that LISA uses logical pathnames in its defsystem, and translations that are suitable for a Linux
(or Cygwin/Windows) environment are

established there. They might work for you; perhaps not. Until

I figure out how to correctly place default translations you might have

to do some hand editing. Sorry.

<p>To build a knowledge base, write your production rules using the various

source examples (and this document) as your guide and load the file(s)

into Lisp. You can then change to the LISA-USER package and experiment.

Look for the examples in "lisa:misc;".

<p>A note to CLISP users. LISA requires that CLISP be run with full ANSI

support enabled. Also, the baseline version with which LISA has been tested

is 2.25.1. Earlier releases might work as well, but no guarantees.

<h3>

IX.&nbsp;<a NAME="Things Yet to Do"></a>Things Yet to Do.</h3>

This section is a list (albeit incomplete) of features that would improve

LISA significantly.

<ol>



<li>

<i>Backward chaining</i>: Perhaps an implementation of Prolog's backchaining
algorithm that has concurrent access to working memory (i.e. along with Rete).<br>
</li>



</ol>



<h3>

<a NAME="Supported Platforms"></a>X. Supported Platforms.</h3>

LISA has been tested, and is known to run, on the following Common Lisp

implementations:

<ul>

<li>

Allegro Common Lisp, versions 5.0.1 and 6.x, Linux and Windows 2000.</li>



<li>

Xanalys LispWorks, versions 4.1.20 and 4.2, Linux and Windows 2000.</li>



<li>

CLISP, version 2.27 and newer, Linux and Windows 2000.</li>



<li>

CMUCL, version 18c, Linux.</li>

</ul>



</body>

</html>

