<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Mozilla/4.76 [en] (X11; U; SunOS 5.8 sun4u) [Netscape]">
</head>
<body background="hierarchy-background.gif">

<center>
<h2>
The LISA Reference Guide</h2></center>
This guide describes in detail the programming interface to LISA. It is
<i>not</i>
a treatise on production-rule technology; readers are assumed to have a
working knowledge of rule-based systems and their development. This document
also avoids any detailed description of LISA's implementation of the Rete
algorithm; perhaps at some future date I'll make an attempt.
<center>
<h2>
Abbreviated Table of Contents</h2></center>
<a href="#The Programming Language">The Programming Language</a>.
<br><a href="#The Environment">The Environment</a>.
<br><a href="#Getting Started">Getting Started</a>.
<br><a href="#Things Yet to Do">Things Yet to Do</a>.
<br>&nbsp;
<h3>
I.&nbsp;<a NAME="The Programming Language"></a>The Programming Language</h3>
This section describes the publicly-available operators in the LISA language,
separated into various categories:
<blockquote><a href="#Fact-Related Operators">Fact-Related Operators</a>
<blockquote>Language elements dealing with facts.</blockquote>
<a href="#Rule-Related Operators">Rule-Related Operators</a>
<blockquote>Language elements dealing with rules.</blockquote>
<a href="#CLOS-Related Operators">CLOS-Related Operators</a>
<blockquote>Language elements dealing with CLOS instances.</blockquote>
<a href="#Engine-Related Operators">Engine-Related Operators</a>
<blockquote>Language elements dealing with operations on an inference engine.</blockquote>
<a href="#Environment-Related Operators">Environment-Related Operators</a>
<blockquote>Language elements dealing with the LISA environment.</blockquote>
<a href="#Debugging-Related Operators">Debugging-Related Operators</a>
<blockquote>Language elements useful during system development.</blockquote>
</blockquote>

<h4>
<a NAME="Fact-Related Operators"></a>Fact-Related Operators</h4>
&nbsp;
<table WIDTH="100%" NOSAVE >
<tr NOSAVE>
<td WIDTH="80%" NOSAVE>(deftemplate <i>name</i> () (<i>slot-name*</i>))</td>

<td>Macro</td>
</tr>
</table>

<blockquote>Creates an internal LISA class identified by <i>name</i> that
can be instantiated as a fact within the knowledge base. The <i>slot-name</i>s
are analogous to class slots, but without any of the keyword arguments.
Templates are a convenient way of specifying concepts that don't need the
full support of CLOS. Reasoning over them is slightly more efficient, both
in terms of time and size.</blockquote>

<table WIDTH="100%" NOSAVE >
<tr NOSAVE>
<td WIDTH="80%" NOSAVE>(defimport <i>symbolic-name</i> (<i>class-name</i>)
(<i>slot-name</i>*))</td>

<td>Macro</td>
</tr>
</table>

<blockquote>Makes a CLOS class known to LISA and allows instances of this
class to be asserted into the knowledge base. The <i>symbolic-name</i>
is the name that will be used in rules and during pattern matching; <i>class-name</i>
is the fully-qualified name of the class as it is known to Lisp. To limit
the slots available for pattern matching, include a list of relevant <i>slot-name</i>s.
If no slot-names are specified LISA will examine the meta class for <i>class-name</i>
and make all of the slots in the class hierarchy available.</blockquote>

<table WIDTH="100%" NOSAVE >
<tr NOSAVE>
<td WIDTH="80%" NOSAVE>(assert (<i>template-name</i> (<i>slot-name value</i>)*))</td>

<td>Macro</td>
</tr>
</table>

<blockquote>Inserts a fact identified by <i>template-name</i> into the
knowledge base. Slot values are assigned using a list of (<i>slot-name
value</i>) pairs. The template associated with <i>template-name</i> must
be known to LISA a priori.</blockquote>

<table WIDTH="100%" NOSAVE >
<tr NOSAVE>
<td WIDTH="80%" NOSAVE>(retract <i>fact</i> &amp;optional <i>engine</i>)</td>

<td>Function</td>
</tr>
</table>

<blockquote>Removes a fact from the knowledge base. The symbol <i>fact</i>
should be bound to either a LISA fact object or an integer representing
the fact identifier. Unless <i>engine</i> is supplied, the inference engine
returned by (current-engine) will be used.</blockquote>

<table WIDTH="100%" NOSAVE >
<tr NOSAVE>
<td WIDTH="80%" NOSAVE>(assert-instance <i>instance</i>)</td>

<td>Function</td>
</tr>
</table>

<blockquote>Inserts a CLOS instance into the knowledge base. The class
of <i>instance</i> should already exist and have been identified to LISA
via a <i>defimport</i>.</blockquote>

<table WIDTH="100%" NOSAVE >
<tr NOSAVE>
<td WIDTH="80%" NOSAVE>(retract-instance <i>instance</i>)</td>

<td>Function</td>
</tr>
</table>

<blockquote>Removes a CLOS instance from the knowledge base. The class
of <i>instance</i> should already exist and have been identified to LISA
via a <i>defimport</i>.</blockquote>

<table WIDTH="100%" NOSAVE >
<tr NOSAVE>
<td WIDTH="80%" NOSAVE>(modify <i>fact</i> (<i>slot-name value</i>)*)</td>

<td>Macro</td>
</tr>
</table>

<blockquote>Makes changes to the fact instance identified by <i>fact</i>.
Affected slots and their new values are specified by (<i>slot-name value</i>).
Note that <i>value</i> can be an arbitrary Lisp expression that will be
evaluated at execution time.</blockquote>

<h4>
<a NAME="Rule-Related Operators"></a>Rule-Related Operators</h4>
&nbsp;
<table WIDTH="100%" NOSAVE >
<tr NOSAVE>
<td WIDTH="80%" NOSAVE>(defrule <i>name (key*) pattern*</i> => <i>action*</i>)</td>

<td NOSAVE>Macro</td>
</tr>
</table>

<blockquote>Creates a rule identified by <i>name</i> and compiles it into
the Rete network. The keyword arguments modify the rule as follows:
<pre>:salience <i>integer</i></pre>

<blockquote>Assigns a priority to the rule that will affect the firing
order. The salience value is a small integer in the range (-250, 250).
By default, all rules have salience 0.</blockquote>

<pre>:module <i>name</i></pre>

<blockquote>Binds the rule to a module identified by the symbol <i>name</i>.
Currently unimplemented.</blockquote>

<h5>
Patterns</h5>
Each rule consists of zero or more <i>pattern</i>s, or Conditional Elements
(CEs). Collectively these patterns are known as the rule's Left Hand Side
(LHS), and are the entities that participate in the pattern-matching process.
LISA currently defines three pattern types:
<pre>generic pattern</pre>

<blockquote>This pattern type matches against facts in the knowledge base.
The head of the pattern matches equivalently-named facts; the pattern body
is optionally composed of slot-names, values, variables and predicates.
The best way to understand these things is to look at some examples:
<pre>(simple-pattern)</pre>

<blockquote>The simplest type of pattern. This example will match any fact
of class <i>simple-pattern</i>.</blockquote>

<pre>(goal-is-to (action unlock))</pre>

<blockquote>This pattern matches facts of class <i>goal-is-to</i>. In addition,
it specifies that the slot named <i>action</i> must have as its value the
symbol <i>unlock</i>.</blockquote>

<pre>(thing (name ?chest) (on-top-of (not floor)))</pre>

<blockquote>A bit more interesting. Matches facts of class <i>thing</i>;
assuming this is the first appearance of the variable <i>?chest</i>, binds
it to the value of the slot <i>name</i>; specifies that the slot <i>on-top-of</i>
should not have as its value the symbol <i>floor</i>.</blockquote>

<pre>(?monkey (monkey (holding ?chest)))</pre>

<blockquote>Assuming the variable <i>?chest</i> was bound in a previous
pattern, matches facts of class <i>monkey</i> whose slot <i>holding</i>
has the same value as <i>?chest</i>. Additionally, if the pattern is successfully
matched, binds the fact object to the variable <i>?monkey</i>. The variable
<i>?monkey</i>
is called a <i>pattern binding</i>.</blockquote>

<pre>(pump (flow-rate ?flow-rate (&lt; ?flow-rate 25)))</pre>

<blockquote>More interesting still. This pattern matches facts of class
<i>pump</i>,
and binds the value of the slot <i>flow-rate</i> to the variable
<i>?flow-rate</i>.
In addition, there is a constraint on this slot declaring that the value
of <i>?flow-rate</i> must be less than 25. In general, constraints can
be arbitrary Lisp expressions that serve as predicates.</blockquote>

<pre>(fact-with-list (list '(1 2 three)))</pre>

<blockquote>Patterns can perform matching on lists as well as simpler data
types. Here, the slot <i>list</i> must have the value <i>'(1 2 three)</i>.
More complicated list analysis can be done using user-defined predicates.</blockquote>
</blockquote>

<pre>negated pattern</pre>

<blockquote>This pattern type is the complement of most variations of the
generic pattern. Negated patterns have the symbol <i>not</i> as their head,
and match if a fact satisfying the pattern is <i>not</i> found. For example:
<pre>(not (tank-level-warning (tank ?tank) (type low)))</pre>
Note that negated patterns are not allowed to have pattern bindings.</blockquote>

<pre>test pattern</pre>

<blockquote>The <i>test</i> conditional element allows one to evaluate
arbitrary Lisp code on the rule LHS; these Lisp forms serve as a predicate
that determines whether or not the pattern will match. For example, the
pattern
<pre>(test (and (high-p ?tank) (intact-p ?tank)))</pre>
will succeed if the AND form returns non-<i>nil</i>; i.e. the functions
HIGH-P and INTACT-P both return non-<i>nil</i> values.</blockquote>
If a rule provides no conditional elements, then it is said to match the
<i>initial-fact</i>,
which is asserted as the result of a call to <i>reset</i>. Thus, the following
rule will always activate after each reset:
<br>&nbsp;
<dd>
(defrule always-fires ()</dd>

<dd>
&nbsp;&nbsp; =></dd>

<dd>
&nbsp;&nbsp; (format t "always-fires fired!~%"))</dd>

<br>&nbsp;
<p>&nbsp;
<p>When a CLOS instance is asserted into the knowledge-base, LISA creates
a special type of fact object to manage it. This object, known as a <i>shadow-fact</i>,
contains a special slot named <i>:object</i> that is bound to the corresponding
CLOS instance. It is possible to bind this slot to a variable just like
any other:
<br>&nbsp;
<dd>
(tank (name ?name) (:object&nbsp; ?tank-object))</dd>
</blockquote>

<dd>
Once bound, method and function calls can be made on this object from the
rule's LHS and RHS.</dd>

<blockquote>
<h5>
Actions</h5>
Following any conditional elements are the rule's actions, if any. Collectively
known as the Right Hand Side (RHS), actions consist of arbitrary Lisp forms;
all variables declared on the LHS are available, along with the special
operator <i>engine</i>, which evaluates to the rule's inference engine
object. Currently, each rule's RHS is given to the Lisp compiler during
rule compilation, and executes within a special lexical environment established
by LISA for each firing.</blockquote>

<h4>
<a NAME="CLOS-Related Operators"></a>CLOS-Related Operators</h4>
There are a few special operators and functions that LISA provides for
managing CLOS instances within the knowledge base.
<br>&nbsp;
<table WIDTH="100%" NOSAVE >
<tr NOSAVE>
<td WIDTH="80%" NOSAVE>(engine)</td>

<td>Macro</td>
</tr>
</table>

<blockquote>Returns the inference engine associated with a particular rule.
Use of this macro only makes sense from within a rule's RHS.</blockquote>

<table WIDTH="100%" NOSAVE >
<tr NOSAVE>
<td WIDTH="80%" NOSAVE>(mark-instance-as-changed <i>instance</i> &amp;optional
<i>slot-id</i>)</td>

<td>Generic function</td>
</tr>
</table>

<blockquote>Notifies LISA that a change has been made to <i>instance</i>
outside of the knowledge-base (i.e. not via the <i>modify</i> operator),
and synchronizes the instance with its associated shadow fact. LISA automatically
generates a specialized method for this function at <i>defimport</i> time;
an application <i>must</i> call this method whenever a slot change occurs
outside of LISA's control.</blockquote>

<table WIDTH="100%" NOSAVE >
<tr NOSAVE>
<td WIDTH="80%" NOSAVE>(tell-lisa-modified-instance <i>instance slot-name</i>)</td>

<td>Generic function</td>
</tr>
</table>

<blockquote>LISA calls this function whenever a change occurs to <i>instance</i>
from within the knowledge base (i.e. via the <i>modify</i> operator). Applications
can specialize on this function if they so choose. The <i>slot-name</i>
specifies the affected slot.</blockquote>

<h4>
<a NAME="Engine-Related Operators"></a>Engine-Related Operators</h4>
These operators provide an interface to instances of the inference engine
itself.
<br>&nbsp;
<table WIDTH="100%" NOSAVE >
<tr NOSAVE>
<td WIDTH="80%" NOSAVE>(reset &amp;optional <i>engine</i>)</td>

<td>Function</td>
</tr>
</table>

<blockquote>Re-initializes the knowledge base of <i>engine;</i> removing
facts, clearing the agenda, and asserting the <i>initial-fact</i>. By default,
operates on the <i>current-engine</i>.</blockquote>

<table WIDTH="100%" NOSAVE >
<tr NOSAVE>
<td WIDTH="80%" NOSAVE>(clear &amp;optional <i>engine</i>)</td>

<td>Function</td>
</tr>
</table>

<blockquote>Re-initializes <i>engine</i> itself; forgetting the rulebase,
facts and agenda. By default, operates on the <i>current-engine</i>.</blockquote>

<table WIDTH="100%" NOSAVE >
<tr NOSAVE>
<td WIDTH="80%" NOSAVE>(run &amp;optional <i>engine</i> &amp;key <i>step)</i></td>

<td>Function</td>
</tr>
</table>

<blockquote>Runs the inference engine bound to <i>engine</i>. Execution
will continue until either the agenda is empty or the number of fired rules
exceeds the value of <i>step</i>. By default, <i>step</i> is bound to a
value that will cause the engine to run until the agenda is exhausted.</blockquote>

<table WIDTH="100%" NOSAVE >
<tr NOSAVE>
<td WIDTH="80%" NOSAVE>(walk &amp;optional <i>step</i>)</td>

<td>Function</td>
</tr>
</table>

<blockquote>Runs the engine in <i>step</i> increments, single-stepping
by default. Here, "single-stepping" means "one rule at a time".</blockquote>

<table WIDTH="100%" NOSAVE >
<tr NOSAVE>
<td WIDTH="80%" NOSAVE>(halt <i>engine</i>)</td>

<td>Function</td>
</tr>
</table>

<blockquote>Halts the inference engine <i>engine</i>, even if the agenda
still has activations. Typically used only on rule RHSs.</blockquote>

<h4>
<a NAME="Environment-Related Operators"></a>Environment-Related Operators</h4>

<blockquote>These operators are used to establish one or more LISA environments.</blockquote>

<table WIDTH="100%" NOSAVE >
<tr NOSAVE>
<td WIDTH="80%" NOSAVE>(use-default-engine)</td>

<td>Function</td>
</tr>
</table>

<blockquote>Create and make available a default instance of the inference
engine. Use this function when you want a basic, single-threaded LISA environment.
Typically, this form will appear near the beginning of a file of LISA constructs
(rules, templates, etc.). It is idempotent; that is, subsequent calls to
the function will <i>not</i> create a new inference engine unless LISA
is completely re-initialized.</blockquote>

<table WIDTH="100%" NOSAVE >
<tr NOSAVE>
<td WIDTH="80%" NOSAVE>(use-engine <i>engine</i>)</td>

<td>Function</td>
</tr>
</table>

<blockquote>Make <i>engine</i> the default inference engine. Use this function
with great care in a multi-processing environment.</blockquote>

<table WIDTH="100%" NOSAVE >
<tr NOSAVE>
<td WIDTH="80%" NOSAVE>(with-inference-engine (<i>engine</i>) <i>forms</i>*)</td>

<td>Macro</td>
</tr>
</table>

<blockquote>Evaluates <i>forms</i> within the context of the inference
engine <i>engine</i>. Under most circumstances, use this macro in a multi-processing
environment to safely load a knowledge base into <i>engine</i>.</blockquote>

<table WIDTH="100%" NOSAVE >
<tr NOSAVE>
<td WIDTH="80%" NOSAVE>(current-engine)</td>

<td>Function</td>
</tr>
</table>

<blockquote>Returns the currently-active inference engine. Usually only
invoked by code running within the context of <i>with-inference-engine</i>.</blockquote>

<h4>
<a NAME="Debugging-Related Operators"></a>Debugging-Related Operators</h4>
These operators are typically used interactively to inspect the state of
an inference engine. Some of these operators are only loosly defined and
need further work.
<br>&nbsp;
<table WIDTH="100%" NOSAVE >
<tr NOSAVE>
<td WIDTH="80%" NOSAVE>(facts &amp;optional <i>engine</i>)</td>

<td>Function</td>
</tr>
</table>

<blockquote>Prints on <i>standard output</i> the contents of the fact base
belonging to <i>engine</i>.</blockquote>

<table WIDTH="100%" NOSAVE >
<tr NOSAVE>
<td WIDTH="80%" NOSAVE>(rules &amp;optional <i>engine</i>)</td>

<td>Function</td>
</tr>
</table>

<blockquote>Prints on <i>standard output</i> the contents of the rule base
belonging to <i>engine</i>.</blockquote>

<table WIDTH="100%" NOSAVE >
<tr NOSAVE>
<td WIDTH="80%" NOSAVE>(agenda &amp;optional <i>engine</i>)</td>

<td>Function</td>
</tr>
</table>

<blockquote>Prints on <i>standard output</i> the contents of the agenda
belonging to <i>engine</i>.</blockquote>

<table WIDTH="100%" NOSAVE >
<tr NOSAVE>
<td WIDTH="80%" NOSAVE>(watch <i>event</i>)</td>

<td>Function</td>
</tr>
</table>

<blockquote>Asks LISA to report the occurrence of <i>event</i> to <i>standard
output</i>. The entire watch facility needs work, especially to accommodate
a multi-inference-engine environment. Also, it would be nice to generalize
the facility such that it behaves more like a "publish/subscribe" mechanism
with "real" events.
<p>Currently, LISA allows monitoring of these events:
<pre>:facts</pre>

<blockquote>Triggers an event each time a fact is asserted or retracted.</blockquote>

<pre>:activations</pre>

<blockquote>Triggers an event each time a rule is added to or removed from
the agenda.</blockquote>

<pre>:rules</pre>

<blockquote>Triggers an event each time a rule is fired.</blockquote>
</blockquote>

<table WIDTH="100%" NOSAVE >
<tr NOSAVE>
<td WIDTH="80%" NOSAVE>(unwatch <i>event</i>)</td>

<td>Function</td>
</tr>
</table>

<blockquote>Disables the monitoring of <i>event</i>. See the documentation
for <i>watch</i> to see the allowable event types.</blockquote>

<table WIDTH="100%" NOSAVE >
<tr NOSAVE>
<td WIDTH="80%" NOSAVE>(watching)</td>

<td>Function</td>
</tr>
</table>

<blockquote>Displays the list of events currently being monitored.</blockquote>

<h3>
II.&nbsp;<a NAME="The Environment"></a>The Environment</h3>

<p><br>For application developers, LISA makes available the LISA-USER package.
Generally, all user-level work should be done in this package; see the
various examples provided in "lisa:misc;".
<br>&nbsp;
<h3>
III.&nbsp;<a NAME="Getting Started"></a>Getting Started.</h3>
LISA requires the Portable Defsystem as maintained by the CLOCC project;
for your convenience, a copy is included in the distribution. Building
LISA should be straight-forward; load "lisa:defsys.lisp" and evaluate (mk:compile-system
:lisa). Note that currently LISA includes a copy of the CLOCC package PORT;
this will build automatically. If you already have PORT in your Lisp you'll
have to edit defsys.lisp until I find a better way to manage this. One
other thing. LISA uses logical pathnames in her defsystem, and translations
that are suitable for a Linux environment are established there. They might
work for you; perhaps not. Once again, until I figure out how to correctly
place default translations you might have to do some hand editing. Sorry.
<p>To build a knowledge base, write your production rules using the various
source examples (and this document) as your guide and load the file into
Lisp. You can then change to the LISA-USER package and experiment. Look
for the examples in "lisa:misc;".
<p>A note to CLISP users. LISA requires that CLISP be run with full ANSI
support enabled. Also, the baseline version with which LISA has been tested
is 2.25.1. Earlier releases might work as well, but no guarantees.
<h3>
IV.&nbsp;<a NAME="Things Yet to Do"></a>Things Yet to Do.</h3>
This section is a list (albeit incomplete) of features that would improve
LISA significantly.
<ol>
<li>
<i>Rule redefinition</i>: LISA doesn't yet support dynamic redefinition
of rules. Before reloading an existing knowledge base one must first CLEAR
the inference engine. Failing to do this will hose the Rete network pretty
good.</li>

<br>&nbsp;
<li>
<i>Ruleset partitioning</i>: LISA doesn't yet support the notion of rule
"modules" or "packets".</li>

<br>&nbsp;
<li>
<i>Better language/engine interface</i>: This is a sore point that I intend
to address soon. I really want LISA to have clean separation between the
rule language implementation and the inference engine. In other words,
I'd like to have a "generic" Rete implementation upon which one can attach
different rule programming languages. If you don't like the language that
comes with LISA, write a new one. That sort of thing.</li>

<br>&nbsp;
<li>
<i>Query language</i>: There should be a way to query the knowlege base
for information. Something similar to Loom's query language would be very
nice.</li>

<br>&nbsp;
<li>
<i>Better CLOS pattern matching</i>: LISA needs to offer better support
for matching on a class's hierarchy, rather than just the class itself.
Currently, LISA doesn't consider the object hierarchy when performing pattern
matching.</li>
</ol>

</body>
</html>
