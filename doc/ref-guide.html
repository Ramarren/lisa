<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Mozilla/4.77 [en] (X11; U; Linux 2.4.2-2 i586) [Netscape]">
</head>
<body background="hierarchy-background.gif">

<center>
<h2>
The LISA Reference Guide</h2></center>
This guide describes in detail the programming interface to LISA. It is
<i>not</i>
a treatise on production-rule technology; readers are assumed to have a
working knowledge of rule-based systems and their development. This document
also avoids any detailed description of LISA's implementation of the Rete
algorithm; perhaps at some future date I'll make an attempt.
<br>&nbsp;
<h3>
I. The Programming Language</h3>
This section describes the publicly-available operators in the LISA language,
separated into various categories.
<h4>
Fact-related Operators</h4>
&nbsp;
<table BORDER WIDTH="100%" NOSAVE >
<tr NOSAVE>
<td WIDTH="80%" NOSAVE>(deftemplate <i>name</i> () (<i>slot-name*</i>))</td>

<td>Macro</td>
</tr>
</table>

<blockquote>Creates an internal LISA class identified by <i>name</i> that
can be instantiated as a fact within the knowledge base. The <i>slot-name</i>s
are analogous to class slots, but without any of the keyword arguments.
Templates are a convenient way of specifying concepts that don't need the
full support of CLOS. Reasoning over them is slightly more efficient, both
in terms of time and size.</blockquote>

<table BORDER WIDTH="100%" NOSAVE >
<tr NOSAVE>
<td WIDTH="80%" NOSAVE>(defimport <i>symbolic-name</i> (<i>class-name</i>)
(<i>slot-name</i>*))</td>

<td>Macro</td>
</tr>
</table>

<blockquote>Makes a CLOS class known to LISA and allows instances of this
class to be asserted into the knowledge base. The <i>symbolic-name</i>
is the name that will be used in rules and during pattern matching; <i>class-name</i>
is the fully-qualified name of the class as it is known to Lisp. To limit
the slots available for pattern matching, include a list of relevant <i>slot-name</i>s.
If no slot-names are specified LISA will examine the meta class for <i>class-name</i>
and make all of the slots in the class hierarchy available.</blockquote>

<table BORDER WIDTH="100%" NOSAVE >
<tr NOSAVE>
<td WIDTH="80%" NOSAVE>(assert (<i>template-name</i> (<i>slot-name value</i>)*))</td>

<td>Macro</td>
</tr>
</table>

<blockquote>Inserts a fact identified by <i>template-name</i> into the
knowledge base. Slot values are assigned using a list of (<i>slot-name
value</i>) pairs. The template associated with <i>template-name</i> must
be known to LISA a priori.</blockquote>

<table BORDER WIDTH="100%" NOSAVE >
<tr NOSAVE>
<td WIDTH="80%" NOSAVE>(retract <i>fact</i> &amp;optional <i>engine</i>)</td>

<td>Function</td>
</tr>
</table>

<blockquote>Removes a fact from the knowledge base. The symbol <i>fact</i>
should be bound to either a LISA fact object or an integer representing
the fact identifier. Unless <i>engine</i> is supplied, the inference engine
returned by (current-engine) will be used.</blockquote>

<table BORDER WIDTH="100%" NOSAVE >
<tr NOSAVE>
<td WIDTH="80%" NOSAVE>(assert-instance <i>instance</i>)</td>

<td>Function</td>
</tr>
</table>

<blockquote>Inserts a CLOS instance into the knowledge base. The class
of <i>instance</i> should already exist and have been identified to LISA
via a <i>defimport</i>.</blockquote>

<table BORDER WIDTH="100%" NOSAVE >
<tr NOSAVE>
<td WIDTH="80%" NOSAVE>(retract-instance <i>instance</i>)</td>

<td>Function</td>
</tr>
</table>

<blockquote>Removes a CLOS instance from the knowledge base. The class
of <i>instance</i> should already exist and have been identified to LISA
via a <i>defimport</i>.</blockquote>

<table BORDER WIDTH="100%" NOSAVE >
<tr NOSAVE>
<td WIDTH="80%" NOSAVE>(modify <i>fact</i> (<i>slot-name value</i>)*)</td>

<td>Macro</td>
</tr>
</table>

<blockquote>Makes changes to the fact instance identified by <i>fact</i>.
Affected slots and their new values are specified by (<i>slot-name value</i>).
Note that <i>value</i> can be an arbitrary Lisp expression that will be
evaluated at execution time.</blockquote>

<h4>
Rule-related Operators</h4>
&nbsp;
<table BORDER WIDTH="100%" NOSAVE >
<tr NOSAVE>
<td WIDTH="80%" NOSAVE>(defrule <i>name (key*) pattern*</i> => <i>action*</i>)</td>

<td NOSAVE>Macro</td>
</tr>
</table>

<blockquote>Creates a rule identified by <i>name</i> and compiles it into
the Rete network. The keyword arguments modify the rule as follows:
<pre>:salience <i>integer</i></pre>

<blockquote>Assigns a priority to the rule that will affect the firing
order. The salience value is a small integer in the range (-250, 250).
By default, all rules have salience 0.</blockquote>

<pre>:module <i>name</i></pre>

<blockquote>Binds the rule to a module identified by the symbol <i>name</i>.
Currently unimplemented.</blockquote>

<h5>
Patterns</h5>
Each rule consists of zero or more <i>pattern</i>s, or Conditional Elements
(CEs). Collectively these patterns are known as the rule's Left Hand Side
(LHS), and are the entities that participate in the pattern-matching process.
LISA currently defines three pattern types:
<pre>generic pattern</pre>

<blockquote>This pattern type matches against facts in the knowledge base.
The head of the pattern matches equivalently-named facts; the pattern body
is optionally composed of slot-names, values, variables and predicates.
The best way to understand these things is to look at some examples:
<pre>(simple-pattern)</pre>

<blockquote>The simplest type of pattern. This example will match any fact
of class <i>simple-pattern</i>.</blockquote>

<pre>(goal-is-to (action unlock))</pre>

<blockquote>This pattern matches facts of class <i>goal-is-to</i>. In addition,
it specifies that the slot named <i>action</i> must have as its value the
symbol <i>unlock</i>.</blockquote>

<pre>(thing (name ?chest) (on-top-of (not floor)))</pre>

<blockquote>A bit more interesting. Matches facts of class <i>thing</i>;
assuming this is the first appearance of the variable <i>?chest</i>, binds
it to the value of the slot <i>name</i>; specifies that the slot <i>on-top-of</i>
should not have as its value the symbol <i>floor</i>.</blockquote>

<pre>(?monkey (monkey (holding ?chest)))</pre>

<blockquote>Assuming the variable <i>?chest</i> was bound in a previous
pattern, matches facts of class <i>monkey</i> whose slot <i>holding</i>
has the same value as <i>?chest</i>. Additionally, if the pattern is successfully
matched, binds the fact object to the variable <i>?monkey</i>. The variable
<i>?monkey</i>
is called a <i>pattern binding</i>.</blockquote>

<pre>(pump (flow-rate ?flow-rate (&lt; ?flow-rate 25)))</pre>

<blockquote>More interesting still. This pattern matches facts of class
<i>pump</i>,
and binds the value of the slot <i>flow-rate</i> to the variable
<i>?flow-rate</i>.
In addition, there is a constraint on this slot declaring that the value
of <i>?flow-rate</i> must be less than 25. In general, constraints can
be arbitrary Lisp expressions that serve as predicates.</blockquote>

<pre>(fact-with-list (list '(1 2 three)))</pre>

<blockquote>Patterns can perform matching on lists as well as simpler data
types. Here, the slot <i>list</i> must have the value <i>'(1 2 three)</i>.
More complicated list analysis can be done using user-defined predicates.</blockquote>
</blockquote>

<pre>negated pattern</pre>

<blockquote>This pattern type is the complement of most variations of the
generic pattern. Negated patterns have the symbol <i>not</i> as their head,
and match if a fact satisfying the pattern is <i>not</i> found. For example:
<pre>(not (tank-level-warning (tank ?tank) (type low)))</pre>
Note that negated patterns are not allowed to have pattern bindings.</blockquote>

<pre>test pattern</pre>

<blockquote>The <i>test</i> conditional element allows one to evaluate
arbitrary Lisp code on the rule LHS; these Lisp forms serve as a predicate
that determines whether or not the pattern will match. For example, the
pattern
<pre>(test (and (high-p ?tank) (intact-p ?tank)))</pre>
will succeed if the AND form returns non-<i>nil</i>; i.e. the functions
HIGH-P and INTACT-P both return non-<i>nil</i> values.</blockquote>
If a rule provides no conditional elements, then it is said to match the
<i>initial-fact</i>,
which is asserted as the result of a call to <i>reset</i>. Thus, the following
rule will always activate after each reset:
<br>&nbsp;
<dd>
(defrule always-fires ()</dd>

<dd>
&nbsp;&nbsp; =></dd>

<dd>
&nbsp;&nbsp; (format t "always-fires fired!~%"))</dd>

<h4>
Actions</h4>
Following any conditional elements are the rule's actions, if any. Collectively
known as the Right Hand Side (RHS), actions consist of arbitrary Lisp forms;
all variables declared on the LHS are available, along with the special
operator <i>engine</i>, which evaluates to the rule's inference engine
object. Currently, each rule's RHS is given to the Lisp compiler during
rule compilation, and executes within a special lexical environment established
by LISA for each firing.</blockquote>

</body>
</html>
