<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
	<META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset=utf-8">
	<TITLE></TITLE>
	<META NAME="GENERATOR" CONTENT="OpenOffice.org 2.2  (Linux)">
	<META NAME="CREATED" CONTENT="20070920;9270400">
	<META NAME="CHANGEDBY" CONTENT="David Young">
	<META NAME="CHANGED" CONTENT="20070920;9301600">
</HEAD>
<BODY LANG="en-US" BACKGROUND="hierarchy-background.gif" DIR="LTR">
<H2 ALIGN=CENTER>The Lisa Reference Guide</H2>
<P>This guide describes in detail the programming interface to Lisa.
It is <I>not</I> a treatise on production-rule technology; readers
are assumed to have a working knowledge of rule-based systems and
their development. This document also avoids any detailed description
of Lisa's implementation of the Rete algorithm; perhaps at some
future date I'll make an attempt. 
</P>
<H2 ALIGN=CENTER>Abbreviated Table of Contents</H2>
<P><A HREF="#The Programming Language">The Programming Language</A>
<BR><A HREF="#The Environment">The Environment</A><BR><A HREF="#Contexts">Contexts</A>
<BR><A HREF="#Dynamic Rule Definition">Dynamic Rule Definition</A>
<BR><A HREF="#Queries">Queries</A> <BR><A HREF="#Conflict Resolution">Conflict
Resolution</A><A HREF="#The LISA Debugger"><BR>The Lisa Debugger<BR></A><A HREF="auto-notify.html">Auto
Notification</A> <BR><A HREF="#Getting Started">Getting Started</A>
<BR><A HREF="#Things Yet to Do">Things Yet to Do</A> <BR><A HREF="#Supported Platforms">Supported
Platforms</A> <BR>&nbsp; 
</P>
<H3><A NAME="The Programming Language"></A>I.&nbsp;The Programming
Language</H3>
<P>This section describes the publicly-available operators in the
Lisa language, separated into various categories: 
</P>
<BLOCKQUOTE><A HREF="#Fact-Related Operators">Fact-Related Operators</A>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-left: 0.79in; margin-right: 0.79in">Language
elements dealing with facts.</BLOCKQUOTE>
<BLOCKQUOTE><A HREF="#Rule-Related Operators">Rule-Related Operators</A>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-left: 0.79in; margin-right: 0.79in">Language
elements dealing with rules.</BLOCKQUOTE>
<BLOCKQUOTE><A HREF="#CLOS-Related Operators">CLOS-Related Operators</A>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-left: 0.79in; margin-right: 0.79in">Language
elements dealing with CLOS instances.</BLOCKQUOTE>
<BLOCKQUOTE><A HREF="#Engine-Related Operators">Engine-Related
Operators</A> 
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-left: 0.79in; margin-right: 0.79in">Language
elements dealing with operations on an inference engine.</BLOCKQUOTE>
<BLOCKQUOTE><A HREF="#Environment-Related Operators">Environment-Related
Operators</A> 
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-left: 0.79in; margin-right: 0.79in">Language
elements dealing with the Lisa environment.</BLOCKQUOTE>
<BLOCKQUOTE><A HREF="#Debugging-Related Operators">Debugging-Related
Operators</A> 
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-left: 0.79in; margin-right: 0.79in">Language
elements useful during system development.</BLOCKQUOTE>
<H4><A NAME="Fact-Related Operators"></A>Fact-Related Operators</H4>
<P STYLE="margin-bottom: 0in">&nbsp; 
</P>
<TABLE WIDTH=100% CELLPADDING=2 CELLSPACING=2>
	<TR>
		<TD WIDTH=80%>
			<P>(deftemplate <I>name</I> () (<I>slot-name*</I>))</P>
		</TD>
		<TD>
			<P>Macro</P>
		</TD>
	</TR>
</TABLE>
<BLOCKQUOTE>Creates an internal Lisa class identified by <I>name</I>
that can be instantiated as a fact within the knowledge base. The
<I>slot-name</I>s are analogous to class slots, but without any of
the keyword arguments. Templates are a convenient way of specifying
concepts that don't need the full support of CLOS, but frankly
they're really only in place to ease the transition from CLIPS and
Jess.&nbsp;</BLOCKQUOTE>
<TABLE WIDTH=100% CELLPADDING=2 CELLSPACING=2>
	<TR>
		<TD WIDTH=80%>
			<P>(deffacts <I>deffact-name</I> (<I>key</I>*) <I>fact-list</I>*)</P>
		</TD>
		<TD>
			<P>Macro</P>
		</TD>
	</TR>
</TABLE>
<BLOCKQUOTE>Registers a list of facts that will be automatically
inserted into the knowledge base upon each RESET. The <I>deffact-name</I>
is the symbolic name that will be attached to this group of facts;
<I>fact-list</I> is a list of fact specifiers. The format of each
fact specifier is identical to that found in an ASSERT form, minus
the <I>assert</I> keyword. There are currently no supported keywords
for this macro.</BLOCKQUOTE>
<TABLE WIDTH=100% CELLPADDING=2 CELLSPACING=2>
	<TR>
		<TD WIDTH=80%>
			<P>(assert (<I>fact-specifier</I>))</P>
		</TD>
		<TD>
			<P>Macro</P>
		</TD>
	</TR>
</TABLE>
<BLOCKQUOTE>Inserts a fact identified by <I>fact-specifier</I> into
the knowledge base. There are two forms of ASSERT; the first operates
on template-based facts, the other on CLOS instances. For templates,
ASSERT takes a symbol representing the name of the template, followed
by a list of (<I>slot-name value</I>) pairs: 
</BLOCKQUOTE>
<DL>
	<DL>
		<DD STYLE="margin-right: 0.39in; margin-bottom: 0.2in">(assert
		(frodo (name frodo) (age 100)) 
		</DD></DL>
</DL>
<BLOCKQUOTE>
If the template associated with a fact has not been declared prior to
its assertion, Lisa will signal a continuable error.</BLOCKQUOTE>
<BLOCKQUOTE>For instances of user-defined classes, ASSERT takes a
form that must evaluate to a CLOS instance:</BLOCKQUOTE>
<DL>
	<DL>
		<DD STYLE="margin-right: 0.39in; margin-bottom: 0.2in">(assert
		((make-instance 'frodo :name 'frodo :age 100))) 
		</DD></DL>
</DL>
<BLOCKQUOTE>
or:</BLOCKQUOTE>
<DL>
	<DL>
		<DD STYLE="margin-right: 0.39in; margin-bottom: 0.2in">(let
		((?instance (make-instance 'frodo :name 'frodo))) 
		</DD><DD STYLE="margin-right: 0.39in; margin-bottom: 0.2in">
		&nbsp;&nbsp;&nbsp; (assert (?instance))) 
		</DD></DL>
</DL>
<BLOCKQUOTE>
or:</BLOCKQUOTE>
<DL>
	<DL>
		<DD STYLE="margin-right: 0.39in; margin-bottom: 0.2in">(defun
		add-my-instance (frodo-object)<BR>&nbsp; (assert (#?frodo-object)))
				</DD></DL>
</DL>
<BLOCKQUOTE>
This last example makes use of the #? reader macro, which Lisa offers
as a user-customisable feature. It's simply a short-hand notation for
<I>(identity frodo-object)</I>.</BLOCKQUOTE>
<TABLE WIDTH=100% CELLPADDING=2 CELLSPACING=2>
	<TR>
		<TD WIDTH=80%>
			<P>(retract <I>fact-or-instance</I>)</P>
		</TD>
		<TD>
			<P>Function</P>
		</TD>
	</TR>
</TABLE>
<BLOCKQUOTE>Removes a fact or instance from the knowledge base. In
the case of a template-based fact, <I>fact-or-instance</I> may be
either a symbol representing the name of the fact, or an integer
mapping to the fact identifier; for CLOS objects <I>fact-or-instance</I>
must be an instance of STANDARD-OBJECT.</BLOCKQUOTE>
<TABLE WIDTH=100% CELLPADDING=2 CELLSPACING=2>
	<TR>
		<TD WIDTH=80%>
			<P>(assert-instance <I>instance</I>)</P>
		</TD>
		<TD>
			<P>Function</P>
		</TD>
	</TR>
</TABLE>
<BLOCKQUOTE>Inserts a CLOS instance into the knowledge base.</BLOCKQUOTE>
<TABLE WIDTH=100% CELLPADDING=2 CELLSPACING=2>
	<TR>
		<TD WIDTH=80%>
			<P>(retract-instance <I>instance</I>)</P>
		</TD>
		<TD>
			<P>Function</P>
		</TD>
	</TR>
</TABLE>
<BLOCKQUOTE>Removes a CLOS instance from the knowledge base.</BLOCKQUOTE>
<TABLE WIDTH=100% CELLPADDING=2 CELLSPACING=2>
	<TR>
		<TD WIDTH=80%>
			<P>(modify <I>fact</I> (<I>slot-name value</I>)*)</P>
		</TD>
		<TD>
			<P>Macro</P>
		</TD>
	</TR>
</TABLE>
<BLOCKQUOTE>Makes changes to the fact instance identified by <I>fact</I>.
Affected slots and their new values are specified by (<I>slot-name
value</I>). Note that <I>value</I> can be an arbitrary Lisp
expression that will be evaluated at execution time.</BLOCKQUOTE>
<H4><A NAME="Rule-Related Operators"></A>Rule-Related Operators</H4>
<P STYLE="margin-bottom: 0in">&nbsp; 
</P>
<TABLE WIDTH=100% CELLPADDING=2 CELLSPACING=2>
	<TR>
		<TD WIDTH=80%>
			<P>(defrule <I>name (key*) pattern*</I> =&gt; <I>action*</I>)</P>
		</TD>
		<TD>
			<P>Macro</P>
		</TD>
	</TR>
</TABLE>
<BLOCKQUOTE>Creates a rule identified by <I>name</I> and compiles it
into the Rete network. <I>Name</I> is any Lisp form that evaluates to
a symbol. The keyword arguments modify the rule as follows: 
</BLOCKQUOTE>
<PRE STYLE="margin-left: 0.39in; margin-right: 0.39in; margin-bottom: 0.2in">:salience <I>integer</I></PRE><BLOCKQUOTE STYLE="margin-left: 0.79in; margin-right: 0.79in">
Assigns a priority to the rule that will affect the firing order. The
salience value is a small integer in the range (-250, 250). By
default, all rules have salience 0.</BLOCKQUOTE>
<PRE STYLE="margin-left: 0.39in; margin-right: 0.39in; margin-bottom: 0.2in">:context <I>name</I></PRE><BLOCKQUOTE STYLE="margin-left: 0.79in; margin-right: 0.79in">
Binds the rule to a context identified by the symbol <I>name</I>. The
context must have been previously defined, or Lisa will signal an
error.</BLOCKQUOTE>
<PRE STYLE="margin-left: 0.39in; margin-right: 0.39in; margin-bottom: 0.2in">:auto-focus <I>t</I></PRE><BLOCKQUOTE STYLE="margin-left: 0.79in; margin-right: 0.79in">
Identifies the rule as requiring &quot;auto focus&quot; behavior.
This means that whenever the rule is activated, its context will be
made the active context after the rule firing completes.</BLOCKQUOTE>
<BLOCKQUOTE>If the rule identified by <I>name</I> already exists in
the Rete network it is replaced by the new definition. 
</BLOCKQUOTE>
<H5 STYLE="margin-left: 0.39in; margin-right: 0.39in; margin-top: 0in">
Patterns</H5>
<BLOCKQUOTE>Each rule consists of zero or more <I>pattern</I>s, or
Conditional Elements (CEs). Collectively these patterns are known as
the rule's Left Hand Side (LHS), and are the entities that
participate in the pattern-matching process. Lisa currently defines
three pattern types: 
</BLOCKQUOTE>
<PRE STYLE="margin-left: 0.39in; margin-right: 0.39in; margin-bottom: 0.2in">generic pattern</PRE><BLOCKQUOTE STYLE="margin-left: 0.79in; margin-right: 0.79in">
This pattern type matches against facts in the knowledge base. The
head of the pattern matches equivalently-named facts; the pattern
body is optionally composed of slot-names, values, variables and
predicates. The best way to understand these things is to look at
some examples: 
</BLOCKQUOTE>
<PRE STYLE="margin-left: 0.79in; margin-right: 0.79in; margin-bottom: 0.2in">(simple-pattern)</PRE><BLOCKQUOTE STYLE="margin-left: 1.18in; margin-right: 1.18in">
The simplest type of pattern. This example will match any fact of
class <I>simple-pattern</I>.</BLOCKQUOTE>
<PRE STYLE="margin-left: 0.79in; margin-right: 0.79in; margin-bottom: 0.2in">(goal-is-to (action unlock))</PRE><BLOCKQUOTE STYLE="margin-left: 1.18in; margin-right: 1.18in">
This pattern matches facts of class <I>goal-is-to</I>. In addition,
it specifies that the slot named <I>action</I> must have as its value
the symbol <I>unlock</I>.</BLOCKQUOTE>
<PRE STYLE="margin-left: 0.79in; margin-right: 0.79in; margin-bottom: 0.2in">(thing (name ?chest) (on-top-of (not floor)))</PRE><BLOCKQUOTE STYLE="margin-left: 1.18in; margin-right: 1.18in">
A bit more interesting. Matches facts of class <I>thing</I>; assuming
this is the first appearance of the variable <I>?chest</I>, binds it
to the value of the slot <I>name</I>; specifies that the slot
<I>on-top-of</I> should not have as its value the symbol <I>floor</I>.</BLOCKQUOTE>
<PRE STYLE="margin-left: 0.79in; margin-right: 0.79in; margin-bottom: 0.2in">(?monkey (monkey (holding ?chest)))</PRE><BLOCKQUOTE STYLE="margin-left: 1.18in; margin-right: 1.18in">
Assuming the variable <I>?chest</I> was bound in a previous pattern,
matches facts of class <I>monkey</I> whose slot <I>holding</I> has
the same value as <I>?chest</I>. Additionally, if the pattern is
successfully matched, binds the fact object to the variable <I>?monkey</I>.
The variable <I>?monkey</I> is called a <I>pattern binding</I>.</BLOCKQUOTE>
<PRE STYLE="margin-left: 0.79in; margin-right: 0.79in; margin-bottom: 0.2in">(pump (flow-rate ?flow-rate (&lt; ?flow-rate 25)))</PRE><BLOCKQUOTE STYLE="margin-left: 1.18in; margin-right: 1.18in">
More interesting still. This pattern matches facts of class <I>pump</I>,
and binds the value of the slot <I>flow-rate</I> to the variable
<I>?flow-rate</I>. In addition, there is a constraint on this slot
declaring that the value of <I>?flow-rate</I> must be less than 25.
In general, constraints can be arbitrary Lisp expressions that serve
as predicates.</BLOCKQUOTE>
<PRE STYLE="margin-left: 0.79in; margin-right: 0.79in; margin-bottom: 0.2in">(fact-with-list (list '(1 2 three)))</PRE><BLOCKQUOTE STYLE="margin-left: 1.18in; margin-right: 1.18in">
Patterns can perform matching on lists as well as simpler data types.
Here, the slot <I>list</I> must have the value <I>'(1 2 three)</I>.
More complicated list analysis can be done using user-defined
predicates.</BLOCKQUOTE>
<PRE STYLE="margin-left: 0.39in; margin-right: 0.39in; margin-bottom: 0.2in">negated pattern</PRE><BLOCKQUOTE STYLE="margin-left: 0.79in; margin-right: 0.79in">
This pattern type is the complement of most variations of the generic
pattern. Negated patterns have the symbol <I>not</I> as their head,
and match if a fact satisfying the pattern is <I>not</I> found. For
example: 
</BLOCKQUOTE>
<PRE STYLE="margin-left: 0.79in; margin-right: 0.79in; margin-bottom: 0.2in">(not (tank-level-warning (tank ?tank) (type low)))</PRE><BLOCKQUOTE STYLE="margin-left: 0.79in; margin-right: 0.79in">
Note that negated patterns are not allowed to have pattern bindings.</BLOCKQUOTE>
<PRE STYLE="margin-left: 0.39in; margin-right: 0.39in; margin-bottom: 0.2in">test pattern</PRE><BLOCKQUOTE STYLE="margin-left: 0.79in; margin-right: 0.79in">
The <I>test</I> conditional element allows one to evaluate arbitrary
Lisp code on the rule LHS; these Lisp forms serve as a predicate that
determines whether or not the pattern will match. For example, the
pattern 
</BLOCKQUOTE>
<PRE STYLE="margin-left: 0.79in; margin-right: 0.79in; margin-bottom: 0.2in">(test (and (high-p ?tank) (intact-p ?tank)))</PRE><BLOCKQUOTE STYLE="margin-left: 0.79in; margin-right: 0.79in">
will succeed if the AND form returns non-<I>nil</I>; i.e. the
functions HIGH-P and INTACT-P both return non-<I>nil</I> values.</BLOCKQUOTE>
<PRE STYLE="margin-left: 0.39in; margin-right: 0.39in; margin-bottom: 0.2in">or pattern</PRE><BLOCKQUOTE STYLE="margin-left: 0.79in; margin-right: 0.79in">
The <I>or</I> conditional element collects any number of patterns
into a logical group, and matches if any of the patterns inside the
<I>or</I> match. If more than one of the sub-patterns matches, the <I>or</I>
group matches more than once. Lisa implements a rule containing an <I>or</I>
CE as a collection of related rules, with each rule representing
exactly one branch. For example, given the following DEFRULE form:</BLOCKQUOTE>
<DL>
	<DL>
		<DL>
			<DD STYLE="margin-right: 0.79in; margin-bottom: 0.2in">(defrule
			frodo ()&nbsp; 
			</DD><DD STYLE="margin-right: 0.79in; margin-bottom: 0.2in">
			&nbsp;&nbsp;&nbsp; (frodo)&nbsp; 
			</DD><DD STYLE="margin-right: 0.79in; margin-bottom: 0.2in">
			&nbsp;&nbsp;&nbsp; (or (bilbo)&nbsp; 
			</DD><DD STYLE="margin-right: 0.79in; margin-bottom: 0.2in">
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (gandalf))&nbsp; 
			</DD><DD STYLE="margin-right: 0.79in; margin-bottom: 0.2in">
			&nbsp;&nbsp;&nbsp; (samwise) 
			</DD><DD STYLE="margin-right: 0.79in; margin-bottom: 0.2in">
			=&gt;) 
			</DD></DL>
	</DL>
</DL>
<BLOCKQUOTE STYLE="margin-left: 0.79in; margin-right: 0.79in">
Lisa will generate two rules into the rete network, a primary rule
and a single sub-rule:</BLOCKQUOTE>
<PRE STYLE="margin-left: 1.18in; margin-right: 1.18in; margin-bottom: 0.2in">frodo: (frodo), (bilbo), (samwise)
frodo~1: (frodo), (gandalf), (samwise)</PRE><BLOCKQUOTE STYLE="margin-left: 0.79in; margin-right: 0.79in">
Notice that Lisa separates the example DEFRULE into the primary rule
<I>frodo</I>, and a single sub-rule, <I>frodo~1</I>. Lisa maintains
the relationship between a primary rule and its sub-rules; if a
primary rule is removed, every related sub-rule is also eliminated.</BLOCKQUOTE>
<PRE STYLE="margin-left: 0.39in; margin-right: 0.39in; margin-bottom: 0.2in">logical pattern</PRE><BLOCKQUOTE STYLE="margin-left: 0.79in; margin-right: 0.79in">
The <I>logical</I> conditional element implements Lisa's notion of
truth maintenance. Patterns appearing within a LOGICAL form in a rule
are conditionally bound to facts asserted from that rule's RHS. If
during inferencing one or more logical facts are retracted (or
asserted in the case of negated patterns), all facts bound to those
logical facts are retracted. Here's an example:</BLOCKQUOTE>
<DL>
	<DL>
		<DL>
			<DD STYLE="margin-right: 0.79in; margin-bottom: 0.2in">(defrule
			frodo () 
			</DD><DD STYLE="margin-right: 0.79in; margin-bottom: 0.2in">
			&nbsp;&nbsp;&nbsp; (logical&nbsp; 
			</DD><DD STYLE="margin-right: 0.79in; margin-bottom: 0.2in">
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (bilbo)&nbsp; 
			</DD><DD STYLE="margin-right: 0.79in; margin-bottom: 0.2in">
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(not (gandalf))) 
			</DD><DT STYLE="margin-right: 0.79in; margin-bottom: 0.2in">
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			(frodo) 
			</DT><DD STYLE="margin-right: 0.79in; margin-bottom: 0.2in">
			=&gt; 
			</DD><DD STYLE="margin-right: 0.79in; margin-bottom: 0.2in">
			(assert (pippin))) 
			</DD></DL>
	</DL>
</DL>
<BLOCKQUOTE STYLE="margin-left: 0.79in; margin-right: 0.79in">
When rule FRODO fires, it asserts a PIPPIN fact that is dependent on
the existence of BILBO and the absence of GANDALF. If either BILBO is
retracted or GANDALF asserted, PIPPIN will be removed as a
consequence.</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-left: 0.79in; margin-right: 0.79in">A
LOGICAL conditional element must be the first pattern in a rule.
Multiple LOGICAL forms within the same rule are allowed, but they
must be contiguous.</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-left: 0.79in; margin-right: 0.79in"><B>NB</B>:
A rule beginning with the LOGICAL conditional element implicitly
matches the INITIAL-FACT; thus, in order for rules employing truth
maintenance to function correctly, a RESET must be always be
performed prior to any operation affecting working memory. Lisa's
behavior is undefined otherwise.</BLOCKQUOTE>
<PRE STYLE="margin-left: 0.39in; margin-right: 0.39in; margin-bottom: 0.2in">exists pattern</PRE><BLOCKQUOTE STYLE="margin-left: 0.79in; margin-right: 0.79in">
The EXISTS conditional element performs an existential test on a
pattern. The pattern will match exactly once, even if there are many
facts that might satisfy it. For example, this rule:</BLOCKQUOTE>
<DL>
	<DL>
		<DL>
			<DD STYLE="margin-right: 0.79in; margin-bottom: 0.2in">(defrule
			frodo ()<BR>&nbsp;&nbsp;&nbsp; (exists (frodo (has-ring t)))<BR>&nbsp;&nbsp;&nbsp;
			=&gt;)</DD></DL>
	</DL>
</DL>
<BLOCKQUOTE STYLE="margin-left: 0.79in; margin-right: 0.79in">
will activate just once if there is at least one FRODO fact whose
HAS-RING slot has the value T.</BLOCKQUOTE>
<PRE STYLE="margin-left: 0.39in; margin-right: 0.39in; margin-bottom: 0.2in">The initial fact</PRE><BLOCKQUOTE>
If a rule provides no conditional elements, then it is said to match
the <I>initial-fact</I>, which is asserted as the result of a call to
<I>reset</I>. Thus, the following rule will always activate after
each reset:</BLOCKQUOTE>
<DL>
	<DL>
		<DD STYLE="margin-right: 0.39in; margin-bottom: 0.2in">(defrule
		always-fires () 
		</DD><DD STYLE="margin-right: 0.39in; margin-bottom: 0.2in">
		&nbsp;&nbsp; =&gt; 
		</DD><DD STYLE="margin-right: 0.39in; margin-bottom: 0.2in">
		&nbsp;&nbsp; (format t &quot;always-fires fired!~%&quot;)) 
		</DD></DL>
</DL>
<PRE STYLE="margin-left: 0.39in; margin-right: 0.39in; margin-bottom: 0.2in">CLOS instances</PRE><BLOCKQUOTE>
Every fact asserted into working memory is backed by a corresponding
CLOS instance. In the case of DEFTEMPLATEs, Lisa creates an internal
class mirroring the template; user-defined class instances are simply
bound to a fact during assertions. Instances associated with facts
are accessible on rule LHSs via the :OBJECT special slot: 
</BLOCKQUOTE>
<DL>
	<DL>
		<DD STYLE="margin-right: 0.39in; margin-bottom: 0.2in">(tank (name
		?name) (:object&nbsp; ?tank-object)) 
		</DD></DL>
</DL>
<BLOCKQUOTE>
Once bound, method and function calls can be made on this object from
the rule's LHS and RHS. 
</BLOCKQUOTE>
<BLOCKQUOTE>When reasoning over CLOS objects, Lisa is capable of
considering an instance's object hierarchy during pattern matching.
In other words, it is possible to write rules that apply to many
facts that share a common ancestry. The following code fragment
provides an example: <BR>&nbsp; 
</BLOCKQUOTE>
<DL>
	<DL>
		<DD STYLE="margin-right: 0.39in; margin-bottom: 0.2in">(defclass
		fundamental () ()) 
		</DD><DD STYLE="margin-right: 0.39in; margin-bottom: 0.2in">
		(defclass rocky (fundamental) ()) 
		</DD><DD STYLE="margin-right: 0.39in; margin-bottom: 0.2in">
		(defclass boris (fundamental) ()) 
		</DD><DT STYLE="margin-right: 0.39in; margin-bottom: 0.2in">
		&nbsp; &nbsp; 
		</DT><DD STYLE="margin-right: 0.39in; margin-bottom: 0.2in">
		(defrule cleanup (:salience -100) 
		</DD><DD STYLE="margin-right: 0.39in; margin-bottom: 0.2in">
		&nbsp;&nbsp;&nbsp; (?fact (fundamental)) 
		</DD><DD STYLE="margin-right: 0.39in; margin-bottom: 0.2in">
		&nbsp;&nbsp;&nbsp;&nbsp; =&gt; 
		</DD><DD STYLE="margin-right: 0.39in; margin-bottom: 0.2in">
		&nbsp;&nbsp;&nbsp; (retract ?fact)) 
		</DD><DT STYLE="margin-right: 0.39in; margin-bottom: 0.2in">
		&nbsp; 
		</DT></DL>
</DL>
<BLOCKQUOTE>
The rule <I>cleanup</I> will fire for every instance of <I>rocky</I>
and <I>boris</I> in the knowledge base, retracting each in turn. Note
that taxonomic reasoning is disabled by default. To use the feature,
evaluate (setf (Lisa:consider-taxonomy) t).</BLOCKQUOTE>
<H5 STYLE="margin-left: 0.39in; margin-right: 0.39in; margin-top: 0in">
Actions</H5>
<BLOCKQUOTE>Following any conditional elements are the rule's
actions, if any. Collectively known as the Right Hand Side (RHS),
actions consist of arbitrary Lisp forms. All variables declared on
the LHS are available, along with the special operator <I>engine</I>,
which evaluates to the rule's inference engine object. Currently,
each rule's RHS is given to the Lisp compiler during rule
compilation, and executes within a special lexical environment
established by Lisa for each firing.</BLOCKQUOTE>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=2 CELLSPACING=2>
	<TR>
		<TD WIDTH=80%>
			<P>(undefrule <I>rule-name</I>)</P>
		</TD>
		<TD>
			<P>Macro</P>
		</TD>
	</TR>
</TABLE>
<BLOCKQUOTE>Undefines, or removes, a rule from the Rete network.
<I>Rule-name</I> is a symbol representing the name of the rule. If
<I>rule-name</I> is not qualified with a context name (e.g.
<I>context.rulename</I>), then the Initial Context is assumed.</BLOCKQUOTE>
<H4><A NAME="CLOS-Related Operators"></A>CLOS-Related Operators</H4>
<P STYLE="margin-bottom: 0in">There are a few special features that
Lisa provides for keeping CLOS instances synchronised with their
corresponding facts in working memory. If an instance is altered
outside of Lisa's control, then Lisa must somehow be informed of the
change to maintain working memory consistency. The basic mechanism is
manual notification, in which an application explicitly invokes a
special function to initiate synchronisation. Users of the two
commercial Lisps supported by Lisa also have the option of employing
<A HREF="auto-notify.html">Auto Notification</A>, an experimental
feature that removes the burden of synchronisation from the
application. <BR>&nbsp; 
</P>
<TABLE WIDTH=100% CELLPADDING=2 CELLSPACING=2>
	<TR>
		<TD WIDTH=80%>
			<P>(mark-instance-as-changed <I>instance </I>&amp;key <I>slot-name</I>)</P>
		</TD>
		<TD>
			<P>Function</P>
		</TD>
	</TR>
</TABLE>
<BLOCKQUOTE>Notifies Lisa that a change has been made to <I>instance</I>
outside of the knowledge-base (i.e. not via the <I>modify</I>
operator), and synchronizes the instance with its associated fact.
<I>Slot-name</I> is either the symbolic name of a slot belonging to
<I>instance</I> that has changed value, or NIL (the default), in
which case all slots are synchronized. An application <I>must</I>
call this method whenever a slot change occurs outside of Lisa's
control.</BLOCKQUOTE>
<H4><A NAME="Engine-Related Operators"></A>Engine-Related Operators</H4>
<P STYLE="margin-bottom: 0in">These operators provide an interface to
instances of the inference engine itself.</P>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=2 CELLSPACING=2>
	<TR>
		<TD WIDTH=80%>
			<P>(inference-engine)</P>
		</TD>
		<TD WIDTH=20%>
			<P>Function</P>
		</TD>
	</TR>
</TABLE>
<BLOCKQUOTE>Evaluates to the currently active instance of the
inference engine.</BLOCKQUOTE>
<TABLE WIDTH=100% CELLPADDING=2 CELLSPACING=2>
	<TR>
		<TD WIDTH=80%>
			<P>(reset)</P>
		</TD>
		<TD>
			<P>Function</P>
		</TD>
	</TR>
</TABLE>
<BLOCKQUOTE>Re-initializes the knowledge base, removing facts,
clearing all context agendas, and asserting the <I>initial-fact</I>.</BLOCKQUOTE>
<TABLE WIDTH=100% CELLPADDING=2 CELLSPACING=2>
	<TR>
		<TD WIDTH=80%>
			<P>(clear)</P>
		</TD>
		<TD>
			<P>Function</P>
		</TD>
	</TR>
</TABLE>
<BLOCKQUOTE>Re-initializes the Lisa environment, mostly by creating a
new instance of the default inference engine.</BLOCKQUOTE>
<TABLE WIDTH=100% CELLPADDING=2 CELLSPACING=2>
	<TR>
		<TD WIDTH=80%>
			<P>(run &amp;optional <I>focus-list)</I></P>
		</TD>
		<TD>
			<P>Function</P>
		</TD>
	</TR>
</TABLE>
<BLOCKQUOTE>Runs the inference engine, optionally pushing the context
names on <I>focus-list</I> onto the focus stack before doing so.
Execution will continue until either all agendas are exhausted or a
rule calls (halt).</BLOCKQUOTE>
<TABLE WIDTH=100% CELLPADDING=2 CELLSPACING=2>
	<TR>
		<TD WIDTH=80%>
			<P>(walk &amp;optional <I>step</I>)</P>
		</TD>
		<TD>
			<P>Function</P>
		</TD>
	</TR>
</TABLE>
<BLOCKQUOTE>Runs the engine in <I>step</I> increments,
single-stepping by default. Here, &quot;single-stepping&quot; means
&quot;one rule at a time&quot;.</BLOCKQUOTE>
<TABLE WIDTH=100% CELLPADDING=2 CELLSPACING=2>
	<TR>
		<TD WIDTH=80%>
			<P>(halt)</P>
		</TD>
		<TD>
			<P>Function</P>
		</TD>
	</TR>
</TABLE>
<BLOCKQUOTE>Halts the inference engine, even if the agendas still
have activations. Typically used only on rule RHSs.</BLOCKQUOTE>
<H4><A NAME="Environment-Related Operators"></A>Environment-Related
Operators</H4>
<BLOCKQUOTE>These operators are used to manipulate and inspect the
Lisa environment.</BLOCKQUOTE>
<TABLE WIDTH=100% CELLPADDING=2 CELLSPACING=2>
	<TR>
		<TD WIDTH=80%>
			<P>(with-inference-engine (<I>engine</I>) <I>forms</I>*)</P>
		</TD>
		<TD>
			<P>Macro</P>
		</TD>
	</TR>
</TABLE>
<BLOCKQUOTE>Evaluates <I>forms</I> within the context of the
inference engine <I>engine</I>. Under most circumstances, use this
macro in a multi-processing environment to safely load a knowledge
base into <I>engine</I>.</BLOCKQUOTE>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=2 CELLSPACING=2>
	<TR>
		<TD WIDTH=80%>
			<P>(make-inference-engine)</P>
		</TD>
		<TD>
			<P>Function</P>
		</TD>
	</TR>
</TABLE>
<BLOCKQUOTE>Creates an instance of Lisa's default inference engine.</BLOCKQUOTE>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=2 CELLSPACING=2>
	<TR>
		<TD WIDTH=80%>
			<P>(rule)</P>
		</TD>
		<TD>
			<P>Function</P>
		</TD>
	</TR>
</TABLE>
<BLOCKQUOTE>Within the context of an executing rule, returns the CLOS
object representing that rule.</BLOCKQUOTE>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=2 CELLSPACING=2>
	<TR>
		<TD WIDTH=80%>
			<P>(consider-taxonomy)</P>
		</TD>
		<TD WIDTH=20%>
			<P>Function</P>
		</TD>
	</TR>
</TABLE>
<BLOCKQUOTE>Returns the current setting for taxonomic reasoning. Use
(setf (consider-taxonomy) <I>value</I>) to change the setting. The
default (NIL) means Lisa ignores class taxonomy during pattern
matching.</BLOCKQUOTE>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=2 CELLSPACING=2>
	<TR>
		<TD WIDTH=80%>
			<P>(allow-duplicate-facts)</P>
		</TD>
		<TD WIDTH=20%>
			<P>Function</P>
		</TD>
	</TR>
</TABLE>
<BLOCKQUOTE>Returns the current setting for duplicate fact checking.
Use (setf (allow-duplicate-facts) <I>value</I>) to change the
setting. By default, Lisa allows duplicate facts to be asserted. If
checking is enabled and an application attempts to assert a duplicate
fact, Lisa signals a DUPLICATE-FACT error.</BLOCKQUOTE>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=2 CELLSPACING=2>
	<TR>
		<TD WIDTH=80%>
			<P>(use-fancy-assert)</P>
		</TD>
		<TD WIDTH=20%>
			<P>Function</P>
		</TD>
	</TR>
</TABLE>
<BLOCKQUOTE>Returns the current setting for fancy assertions. If
enabled (the default), the #? reader macro is installed in the global
readtable.</BLOCKQUOTE>
<H4><A NAME="Debugging-Related Operators"></A>Debugging-Related
Operators</H4>
<P STYLE="margin-bottom: 0in">These operators are typically used
interactively to inspect the state of an inference engine. Some of
these operators are only loosly defined and need further work. <BR>&nbsp;
</P>
<TABLE WIDTH=100% CELLPADDING=2 CELLSPACING=2>
	<TR>
		<TD WIDTH=80%>
			<P>(facts)</P>
		</TD>
		<TD>
			<P>Function</P>
		</TD>
	</TR>
</TABLE>
<BLOCKQUOTE>Prints on <I>trace output</I> the contents of the active
inference engine's fact base.</BLOCKQUOTE>
<TABLE WIDTH=100% CELLPADDING=2 CELLSPACING=2>
	<TR>
		<TD WIDTH=80%>
			<P>(rules &amp;optional <I>context-name</I>)</P>
		</TD>
		<TD>
			<P>Function</P>
		</TD>
	</TR>
</TABLE>
<BLOCKQUOTE>Prints on <I>trace output</I> the contents of the active
inference engine's rule base. By default, all rules and all contexts
will be printed. If <I>context-name</I> is provided, then only those
rules in that context are printed.</BLOCKQUOTE>
<TABLE WIDTH=100% CELLPADDING=2 CELLSPACING=2>
	<TR>
		<TD WIDTH=80%>
			<P>(agenda &amp;optional <I>context-name</I>)</P>
		</TD>
		<TD>
			<P>Function</P>
		</TD>
	</TR>
</TABLE>
<BLOCKQUOTE>Prints on <I>trace output</I> the contents of the active
inference engine's agenda. By default, the agendas for all contexts
will be printed, unless <I>context-name</I> is supplied.</BLOCKQUOTE>
<TABLE WIDTH=100% CELLPADDING=2 CELLSPACING=2>
	<TR>
		<TD WIDTH=80%>
			<P>(watch <I>event</I>)</P>
		</TD>
		<TD>
			<P>Function</P>
		</TD>
	</TR>
</TABLE>
<BLOCKQUOTE>Asks Lisa to report the occurrence of <I>event</I> to
<I>trace output</I>. 
</BLOCKQUOTE>
<BLOCKQUOTE>Currently, Lisa allows monitoring of these events: 
</BLOCKQUOTE>
<PRE STYLE="margin-left: 0.39in; margin-right: 0.39in; margin-bottom: 0.2in">:facts</PRE><BLOCKQUOTE STYLE="margin-left: 0.79in; margin-right: 0.79in">
Triggers an event each time a fact is asserted or retracted.</BLOCKQUOTE>
<PRE STYLE="margin-left: 0.39in; margin-right: 0.39in; margin-bottom: 0.2in">:activations</PRE><BLOCKQUOTE STYLE="margin-left: 0.79in; margin-right: 0.79in">
Triggers an event each time a rule is added to or removed from the
agenda.</BLOCKQUOTE>
<PRE STYLE="margin-left: 0.39in; margin-right: 0.39in; margin-bottom: 0.2in">:rules</PRE><BLOCKQUOTE STYLE="margin-left: 0.79in; margin-right: 0.79in">
Triggers an event each time a rule is fired.</BLOCKQUOTE>
<PRE STYLE="margin-left: 0.39in; margin-right: 0.39in; margin-bottom: 0.2in">:all</PRE><BLOCKQUOTE STYLE="margin-left: 0.79in; margin-right: 0.79in">
Watch all allowable events.</BLOCKQUOTE>
<TABLE WIDTH=100% CELLPADDING=2 CELLSPACING=2>
	<TR>
		<TD WIDTH=80%>
			<P>(unwatch <I>event</I>)</P>
		</TD>
		<TD>
			<P>Function</P>
		</TD>
	</TR>
</TABLE>
<BLOCKQUOTE>Disables the monitoring of <I>event</I>. See the
documentation for <I>watch</I> to see the allowable event types.</BLOCKQUOTE>
<TABLE WIDTH=100% CELLPADDING=2 CELLSPACING=2>
	<TR>
		<TD WIDTH=80%>
			<P>(watching)</P>
		</TD>
		<TD>
			<P>Function</P>
		</TD>
	</TR>
</TABLE>
<BLOCKQUOTE>Displays the list of events currently being monitored.</BLOCKQUOTE>
<H3><A NAME="The Environment"></A>II.&nbsp;The Environment</H3>
<P>For application developers, Lisa makes available two different
types of environments. Package Lisa-USER contains all of Lisa's
exported symbols, plus those of COMMON-LISP. User-level work can
safely be done in this package. Alternatively, package Lisa-LISP can
be used with DEFPACKAGE forms to import a Lisa environment into
user-defined packages: 
</P>
<BLOCKQUOTE>(defpackage &quot;FRODO&quot;<BR>&nbsp; (:use
&quot;Lisa-LISP&quot;))</BLOCKQUOTE>
<P>As with Lisa-USER, Lisa-LISP exports all external symbols in the
Lisa and COMMON-LISP packages. See the various examples provided in
&quot;Lisa:misc;&quot;.</P>
<P>There are a few aspects of Lisa that may be customised prior to
building. The file &quot;Lisa:src;config;config.lisp&quot; contains a
set of default behaviors; feel free to edit this file to your liking.</P>
<H3><A NAME="Contexts"></A>III. Contexts</H3>
<P>Lisa contexts are a way of partitioning a knowledge base into
distinct groups of rules. The mechanism is similar to modules in
CLIPS and recent versions of Jess, in that individual rule groups can
be invoked &quot;procedurally&quot; without resorting to the use of
control facts to manipulate firing order. Contexts can also serve as
an organizational construct when working with larger knowledge bases.
Each context has its own agenda and conflict resolution strategy.</P>
<P>Each inference engine instance created in Lisa contains a default
context, named &quot;The Initial Context&quot; (or INITIAL-CONTEXT).
Unless arrangements are made otherwise, all rules will reside in this
context.&nbsp; The DEFCONTEXT macro creates a new context; rules may
then be loaded into the new context by supplying the :CONTEXT keyword
to DEFRULE. Contexts serve as a form of namespace for rules; thus, it
is legal for identically named rules to reside in different contexts.
Rules are distinctly identified by qualifying the rule name with the
context name; for example, rule <I>wizards.gandalf</I> is a rule
named <I>gandalf</I> that resides within the <I>wizards</I> context.</P>
<P>Activations in the Initial Context are always available for
firing. Otherwise, activations in other contexts will only fire if
those contexts are explicitly given control, via the FOCUS operator.
Each inference engine maintains its own focus stack; before a new
context is given control, the active context is pushed onto the focus
stack. The REFOCUS operator may be used on a rule's RHS (or, perhaps,
interactively) to leave the active context and return control to the
previous context on the stack. Control automatically returns to the
previous context if the active context runs out of activations. When
all contexts have exhausted their activations, the inference engine
halts.</P>
<P>A rule can be tagged with the <I>auto-focus</I> attribute by
supplying the AUTO-FOCUS keyword to DEFRULE. If an auto-focus rule
activates, that rule's context is automatically pushed onto the focus
stack and given control when the rule completes its firing.</P>
<P>Note carefully that while the <I>rules</I> in a knowledge base may
be partitioned, there remains a <I>single working memory</I> per
inference engine. At any given time, all facts in a knowledge base
are visible to all rules in that knowledge base, regardless of
context.</P>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=2 CELLSPACING=2>
	<TR>
		<TD WIDTH=80%>
			<P>(defcontext <I>context-name</I> &amp;key <I>strategy</I>)</P>
		</TD>
		<TD WIDTH=20%>
			<P>Macro</P>
		</TD>
	</TR>
</TABLE>
<BLOCKQUOTE>Creates a new context identified by <I>context-name</I>,
which must be a string designator. If <I>strategy</I> is non-NIL then
it must be an object implementing a suitable conflict resolution
strategy.</BLOCKQUOTE>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=2 CELLSPACING=2>
	<TR>
		<TD WIDTH=80%>
			<P>(undefcontext <I>context-name</I>)</P>
		</TD>
		<TD WIDTH=20%>
			<P>Macro</P>
		</TD>
	</TR>
</TABLE>
<BLOCKQUOTE>Destroys the context identified by <I>context-name</I>,
which must be a string designator. All rules bound to the context are
removed from the Rete network, along with their activations, if any.</BLOCKQUOTE>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=2 CELLSPACING=2>
	<TR>
		<TD WIDTH=80%>
			<P>(focus &amp;rest <I>context-names</I>)</P>
		</TD>
		<TD WIDTH=20%>
			<P>Macro</P>
		</TD>
	</TR>
</TABLE>
<BLOCKQUOTE>If <I>context-names</I> is non-NIL, it should be a
collection of context names that will be added to the focus stack.
Contexts are pushed onto the focus stack in right-to-left order. If
no names are specified, then FOCUS returns the active context object.</BLOCKQUOTE>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=2 CELLSPACING=2>
	<TR>
		<TD WIDTH=80%>
			<P>(refocus)</P>
		</TD>
		<TD WIDTH=20%>
			<P>Macro</P>
		</TD>
	</TR>
</TABLE>
<BLOCKQUOTE>Activates the next available context.</BLOCKQUOTE>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=2 CELLSPACING=2>
	<TR>
		<TD WIDTH=80%>
			<P>(focus-stack)</P>
		</TD>
		<TD WIDTH=20%>
			<P>Macro</P>
		</TD>
	</TR>
</TABLE>
<BLOCKQUOTE>Returns the inference engine's focus stack.</BLOCKQUOTE>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=2 CELLSPACING=2>
	<TR>
		<TD WIDTH=80%>
			<P>(contexts)</P>
		</TD>
		<TD WIDTH=20%>
			<P>Macro</P>
		</TD>
	</TR>
</TABLE>
<BLOCKQUOTE>Returns a list of all the inference engine's defined
contexts.</BLOCKQUOTE>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=2 CELLSPACING=2>
	<TR>
		<TD WIDTH=80%>
			<P>(with-context (<I>context</I> &amp;body <I>body</I>)</P>
		</TD>
		<TD WIDTH=20%>
			<P>Macro</P>
		</TD>
	</TR>
</TABLE>
<BLOCKQUOTE>Evaluates the forms contained in <I>body</I> within the
context <I>context</I>.</BLOCKQUOTE>
<H3><A NAME="Dynamic Rule Definition"></A>IV.&nbsp;Dynamic Rule
Definition</H3>
<P>In addition to statically declared rules, Lisa supports the
definition of rules at runtime. That is, it is possible to create new
rules from the RHSs of existing rules as they fire. These <I>dynamically
defined</I> rules become immediately available to the inference
engine for potential activation. As a simple example, consider the
following rule:</P>
<BLOCKQUOTE>(defrule rocky () <BR>&nbsp; (rocky (name ?name)) <BR>&nbsp;
=&gt; <BR>&nbsp; (defrule boris () <BR>&nbsp;&nbsp;&nbsp; (boris
(name ?name)) <BR>&nbsp;&nbsp;&nbsp; =&gt; <BR>&nbsp;&nbsp;&nbsp;
(format t &quot;Dynamic rule BORIS fired; NAME is ~S~%&quot; ?name)))</BLOCKQUOTE>
<P>When rule ROCKY fires, its RHS creates a dynamically defined rule
named BORIS. This new rule is inserted into the inference engine and
immediately becomes part of the Rete network. Variables bound on the
LHS of ROCKY behave as expected within the context of BORIS; this
means that ?NAME in BORIS is bound to the same object as that found
in ROCKY<SUP>*</SUP>. 
</P>
<P>Here's a more complicated example: 
</P>
<BLOCKQUOTE>(defrule rocky () <BR>&nbsp; (rocky (name ?name)) <BR>&nbsp;
=&gt; <BR>&nbsp; (let ((dynamic-rule <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(defrule (gensym) () <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(boris (name ?name)) <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
=&gt; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(format t &quot;Dynamic rule ~A fired; name is ~S~%&quot; (get-name
(rule)) ?name)))) <BR>&nbsp;&nbsp;&nbsp; (format t &quot;Rule ROCKY
added dynamic rule ~A~%&quot; (get-name dynamic-rule))))</BLOCKQUOTE>
<P>As before, rule ROCKY creates a dynamic rule when fired. However,
this time the new rule is given a unique name by evaluating the form
(GENSYM); either the name or the instance can then be remembered for
use later. These two rules also introduce functions in the Lisa API
for retrieving both the currently executing rule and its name (RULE
and GET-NAME, respectively). 
</P>
<P><SUP>*</SUP> Actually, this isn't precisely true. Whenever Lisa
encounters a dynamic rule during parsing it looks at all the rule's
variables and substitutes any bound values. Thus, in rule BORIS the
variable ?NAME would be replaced by the value of ?NAME as bound in
rule ROCKY. 
</P>
<H3><A NAME="Queries"></A>V.&nbsp;Queries</H3>
<P>As of Lisa version 1.2, a simple query language is supported that
allows retrieval of facts from a knowledge base, either interactively
via a Lisp listener or programmatically. The query engine leverages
the inferencing component by transforming query expressions into
rules and inserting them, at runtime, into the Rete network. Each
query is assigned a unique identifier and cached upon first
appearance; subsequent queries with semantically equivalent bodies
will find the cached instance and execute with substantially improved
performance, especially for larger knowledge bases. As an example,
consider the following two query forms: 
</P>
<P>&nbsp; (retrieve (?x ?y) <BR>&nbsp;&nbsp;&nbsp; (?x (hobbit (name
?name))) <BR>&nbsp;&nbsp;&nbsp; (?y (ring-bearer (name ?name)))) 
</P>
<P>&nbsp; (retrieve (?h1 ?h2) <BR>&nbsp;&nbsp;&nbsp; (?h1 (hobbit
(name ?hobbit-name))) <BR>&nbsp;&nbsp;&nbsp; (?h2 (ring-bearer (name
?hobbit-name)))) 
</P>
<P>The variables appearing in the first argument to RETRIEVE (e.g.
'(?x ?y)) are used to establish bindings for each firing of the
query; each variable must also appear in the query body as an
appropriate pattern binding. Other than this requirement, query
bodies are structurally identical to rule bodies; anything that is
legal in a rule LHS is legal in a query body. Note that these two
examples are semantically equivalent; although the variable names are
different, the patterns appear in the same order and the
relationships among variables are identical. Thus, firing either
query will yield the same set of fact bindings. Lisa is able to
recognize such similarities in queries and implements a caching
scheme that minimizes unnecessary dynamic rule creation. 
</P>
<P>RETRIEVE returns two values; a list of bindings for each query
firing, and the symbolic name assigned by Lisa to the query instance.
The second value is probably only useful while developing/testing
queries; using this symbol one can ask Lisa to forget about a query
by removing it from the cache and the Rete network. The binding list
is the principal value of interest. Since a query is really a rule,
it can fire an arbitrary number of times for each invocation. Each
firing is represented as a list of CONS cells. The CAR of each cell
is one of the variables specified in the query's binding list; its
CDR is a fact bound to that variable that satisfies the variable's
associated pattern. For example, assuming that the first of the above
query examples fires twice during a certain invocation, RETRIEVE
would return something like: 
</P>
<P>&nbsp; (((?X . &lt;HOBBIT INSTANCE 1&gt;) (?Y . &lt;RING-BEARER
INSTANCE 1&gt;)) <BR>&nbsp;&nbsp;&nbsp; ((?X . &lt;HOBBIT INSTANCE
2&gt;) (?Y . &lt;RING-BEARER INSTANCE 2))) <BR>&nbsp; #:G7777 
</P>
<P>As explained previously, the second value is the symbolic name
Lisa assigned to the query when its rule instance was initially
created. Most of the time it will be ignored. 
</P>
<P>As of release 1.3, Lisa incorporates a unified view of template-
and CLOS-based facts; as a result queries now function for both types
of facts. In the former case, Lisa creates a class modeled around the
template. Class and slot names are taken directly from the
DEFTEMPLATE form; each slot is given a reader method named according
to DEFSTRUCT conventions (i.e. <I>class name-slot name</I>). For
example,&nbsp; 
</P>
<BLOCKQUOTE>(deftemplate frodo ()<BR>&nbsp; (slot companion (default
merry))) 
</BLOCKQUOTE>
<P>Will yield the following class specification: 
</P>
<BLOCKQUOTE>(defclass frodo (inference-engine-object)<BR>&nbsp;
((companion :initform 'merry :initarg :companion :reader
frodo-companion))) 
</BLOCKQUOTE>
<P STYLE="margin-bottom: 0in">These functions and macros comprise the
current interface to the query engine: <BR>&nbsp; 
</P>
<TABLE COLS=2 WIDTH=100% CELLPADDING=2 CELLSPACING=2>
	<TR>
		<TD WIDTH=80%>
			<P>(retrieve (<I>variables</I>*) <I>patterns</I>*)</P>
		</TD>
		<TD>
			<P>Macro</P>
		</TD>
	</TR>
</TABLE>
<BLOCKQUOTE>Initiates a query against the knowledge base. Variable
bindings for the query are found in <I>variables; patterns</I>
consists of matching forms that comprise the body of the query rule.
RETRIEVE returns two values: a list of CONS cells for each firing and
the symbolic name Lisa assigned to the query when it was initially
constructed. The CAR of each CONS cell is one of the binding
variables; the CDR is the CLOS instance bound to that variable.</BLOCKQUOTE>
<TABLE COLS=2 WIDTH=100% CELLPADDING=2 CELLSPACING=2>
	<TR>
		<TD WIDTH=80%>
			<P>(forget-query <I>name</I>)</P>
		</TD>
		<TD>
			<P>Function</P>
		</TD>
	</TR>
</TABLE>
<BLOCKQUOTE>Instructs Lisa to forget about the query identified by
the symbol <I>name</I>. Doing so removes the query's rule instance
from the Rete network and the query itself from the cache. Useful
only during query development, probably.</BLOCKQUOTE>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=2 CELLSPACING=2>
	<TR>
		<TD WIDTH=80%>
			<P>(with-simple-query ((<I>var value</I>) <I>query-form</I> &amp;body
			<I>body</I>))</P>
		</TD>
		<TD WIDTH=20%>
			<P>Macro</P>
		</TD>
	</TR>
</TABLE>
<BLOCKQUOTE>Evaluates <I>query-form</I>. Then, iterates over the
resulting list structure, binding each variable and fact to <I>var</I>
and <I>value</I>, respectively, and evaluating <I>body</I>. This
macro is useful if one is interested in just the individual
variable/fact pairs and doesn't care much about the binding context
that occurred during query firing.</BLOCKQUOTE>
<H3><A NAME="Conflict Resolution"></A>VI.&nbsp;Conflict Resolution</H3>
<P STYLE="margin-bottom: 0in">Conflict Resolution (CR) is the
mechanism Lisa employs to determine the order in which multiple
activations will fire. Currently, Lisa offers two &quot;built-in&quot;
strategies; <I>breadth-first</I> and <I>depth-first</I>. It is
possible to implement new CR algorithms by creating a class derived
from <I>Lisa:strategy</I> and implementing a few generic functions;
instances of this new strategy can then be given to
<I>make-inference-engine</I>. <BR>&nbsp; 
</P>
<TABLE WIDTH=100% CELLPADDING=2 CELLSPACING=2>
	<TR>
		<TD WIDTH=80%>
			<P>(add-activation <I>strategy</I> <I>activation</I>)</P>
		</TD>
		<TD>
			<P>Generic Function</P>
		</TD>
	</TR>
</TABLE>
<BLOCKQUOTE>Makes a new <I>activation</I> eligible for firing.</BLOCKQUOTE>
<TABLE WIDTH=100% CELLPADDING=2 CELLSPACING=2>
	<TR>
		<TD WIDTH=80%>
			<P>(find-activation <I>strategy</I> <I>rule</I> <I>token</I>)</P>
		</TD>
		<TD>
			<P>Generic Function</P>
		</TD>
	</TR>
</TABLE>
<BLOCKQUOTE>Locates an activation associated with <I>rule</I> and
<I>token</I>.</BLOCKQUOTE>
<TABLE WIDTH=100% CELLPADDING=2 CELLSPACING=2>
	<TR>
		<TD WIDTH=80%>
			<P>(next-activation <I>strategy</I>)</P>
		</TD>
		<TD>
			<P>Generic Function</P>
		</TD>
	</TR>
</TABLE>
<BLOCKQUOTE>Returns the next eligible activation.</BLOCKQUOTE>
<TABLE WIDTH=100% CELLPADDING=2 CELLSPACING=2>
	<TR>
		<TD WIDTH=80%>
			<P>(list-activations <I>strategy</I>)</P>
		</TD>
		<TD>
			<P>Generic Function</P>
		</TD>
	</TR>
</TABLE>
<BLOCKQUOTE>Returns a list of eligible activations.</BLOCKQUOTE>
<P>Documentation for the CR interface is still fairly light. Look for
improvements in upcoming releases. 
</P>
<H3><A NAME="The LISA Debugger"></A>VII. The Lisa Debugger</H3>
<P>New as of 2.0 alpha 4, the Lisa debugger is a simple monitoring
and inspection utility that may be used to &quot;debug&quot;
production rules. Although one cannot step through a rule pattern by
pattern, breakpoints may be set to trigger just before a rule fires.
When a breakpoint is reached, one can then interactively examine the
token stack, display all pattern bindings and their values,
single-step into the next activation, etc.</P>
<P>By default, Lisa builds without the debugger loaded to avoid a
slight performance drag on rule firings. To use the debugger, in the
CL-USER package evaluate the form (require 'Lisa-debugger
(Lisa-debugger)). If you're running Allegro Common Lisp, Lisa
understands how to hook into the module search list; thus you may
instead evaluate (require 'Lisa-debugger).</P>
<P>The functionality available via the Lisa debugger may increase as
user needs dictate; here is the command set as of this writing:</P>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=2 CELLSPACING=2>
	<TR>
		<TD WIDTH=80%>
			<P>(set-break <I>rule-name</I>)</P>
		</TD>
		<TD WIDTH=20%>
			<P>Function</P>
		</TD>
	</TR>
</TABLE>
<BLOCKQUOTE>Sets a breakpoint in the rule identified by the symbol
<I>rule-name.</I></BLOCKQUOTE>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=2 CELLSPACING=2>
	<TR>
		<TD WIDTH=80%>
			<P>(clear-break <I>rule-name</I>)</P>
		</TD>
		<TD WIDTH=20%>
			<P>Function</P>
		</TD>
	</TR>
</TABLE>
<BLOCKQUOTE>Clears the breakpoint previously set on the rule
identified by the symbol <I>rule-name</I>.</BLOCKQUOTE>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=2 CELLSPACING=2>
	<TR>
		<TD WIDTH=80%>
			<P>(clear-breaks)</P>
		</TD>
		<TD WIDTH=20%>
			<P>Function</P>
		</TD>
	</TR>
</TABLE>
<BLOCKQUOTE>Removes all breakpoints.</BLOCKQUOTE>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=2 CELLSPACING=2>
	<TR>
		<TD WIDTH=80%>
			<P>*break-on-subrules*</P>
		</TD>
		<TD WIDTH=20%>
			<P>Special variable</P>
		</TD>
	</TR>
</TABLE>
<BLOCKQUOTE>Setting this variable to a non-NIL value will cause the
debugger to manage breakpoints for a primary rule and all of its
subrules (see the section on the <I>or</I> conditional element for an
explanation of primary rules).</BLOCKQUOTE>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=2 CELLSPACING=2>
	<TR>
		<TD WIDTH=80%>
			<P>(next)</P>
		</TD>
		<TD WIDTH=20%>
			<P>Function</P>
		</TD>
	</TR>
</TABLE>
<BLOCKQUOTE>Fires the currently suspended rule, then single-steps
into the next activation, if there is one. If there isn't one, the
debugger exits.</BLOCKQUOTE>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=2 CELLSPACING=2>
	<TR>
		<TD WIDTH=80%>
			<P>(resume)</P>
		</TD>
		<TD WIDTH=20%>
			<P>Function</P>
		</TD>
	</TR>
</TABLE>
<BLOCKQUOTE>Resumes normal execution, until the next breakpoint is
reached.</BLOCKQUOTE>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=2 CELLSPACING=2>
	<TR>
		<TD WIDTH=80%>
			<P>(tokens &amp;key (<I>verbose nil</I>))</P>
		</TD>
		<TD WIDTH=20%>
			<P>Function</P>
		</TD>
	</TR>
</TABLE>
<BLOCKQUOTE>&nbsp;Displays the token stack, which contains the facts
that activated this particular rule. If <I>verbose</I> is non-nil,
then the fact instances themselves are printed; otherwise, a
shorthand notation is used.</BLOCKQUOTE>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=2 CELLSPACING=2>
	<TR>
		<TD WIDTH=80%>
			<P>(bindings)</P>
		</TD>
		<TD WIDTH=20%>
			<P>Function</P>
		</TD>
	</TR>
</TABLE>
<BLOCKQUOTE>Displays the bindings (pattern variables) found on the
rule's LHS, along with their values.</BLOCKQUOTE>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=2 CELLSPACING=2>
	<TR>
		<TD WIDTH=80%>
			<P>(fact <I>fact-id</I>)</P>
		</TD>
		<TD WIDTH=20%>
			<P>Function</P>
		</TD>
	</TR>
</TABLE>
<BLOCKQUOTE>Returns the fact instance associated with <I>fact-id</I>,
a small integer assigned to each fact by the inference engine.</BLOCKQUOTE>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=2 CELLSPACING=2>
	<TR>
		<TD WIDTH=80%>
			<P>(breakpoints)</P>
		</TD>
		<TD WIDTH=20%>
			<P>Function</P>
		</TD>
	</TR>
</TABLE>
<BLOCKQUOTE>Displays all breakpoints.</BLOCKQUOTE>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=2 CELLSPACING=2>
	<TR>
		<TD WIDTH=80%>
			<P>(rule)</P>
		</TD>
		<TD WIDTH=20%>
			<P>Function</P>
		</TD>
	</TR>
</TABLE>
<BLOCKQUOTE>Returns the rule instance representing the suspended
activation.</BLOCKQUOTE>
<H3><A NAME="Getting Started"></A>VIII.&nbsp;Getting Started</H3>
<P>Lisa requires the Portable Defsystem as maintained by the CLOCC
project; for your convenience, a copy is included in the
distribution. Building Lisa should be straight-forward. First, either
load &quot;Lisa:Lisa.system&quot; or change your working directory to
the Lisa root directory; then, evaluate (mk:compile-system :Lisa).
Note that Lisa uses logical pathnames in its defsystem, and
translations that are suitable for a Linux (or Cygwin/Windows)
environment are established there. They might work for you; perhaps
not. Until I figure out how to correctly place default translations
you might have to do some hand editing. Sorry. 
</P>
<P>To build a knowledge base, write your production rules using the
various source examples (and this document) as your guide and load
the file(s) into Lisp. You can then change to the Lisa-USER package
and experiment. Look for the examples in &quot;Lisa:misc;&quot;. 
</P>
<P>A note to CLISP users. Lisa requires that CLISP be run with full
ANSI support enabled. Also, the baseline version with which Lisa has
been tested is 2.25.1. Earlier releases might work as well, but no
guarantees. 
</P>
<H3><A NAME="Things Yet to Do"></A>IX.&nbsp;Things Yet to Do.</H3>
<P>This section is a list (albeit incomplete) of features that would
improve Lisa significantly. 
</P>
<OL>
	<LI><P><I>Backward chaining</I>: Perhaps an implementation of
	Prolog's backchaining algorithm that has concurrent access to
	working memory (i.e. along with Rete).</P>
</OL>
<H3><A NAME="Supported Platforms"></A>X. Supported Platforms.</H3>
<P>Lisa has been tested, and is known to run, on the following Common
Lisp implementations: 
</P>
<UL>
	<LI><P STYLE="margin-bottom: 0in">Allegro Common Lisp, versions
	5.0.1 and 6.x, Linux and Windows 2000. 
	</P>
	<LI><P STYLE="margin-bottom: 0in">Xanalys LispWorks, versions 4.1.20
	and 4.2, Linux and Windows 2000. 
	</P>
	<LI><P STYLE="margin-bottom: 0in">CLISP, version 2.27 and newer,
	Linux and Windows 2000. 
	</P>
	<LI><P>CMUCL, version 18c, Linux. 
	</P>
</UL>
</BODY>
</HTML>