;;; -*- Lisp -*-

;;; This file is part of LISA, the Lisp-based Intelligent Software
;;; Agents platform.

;;; Copyright (C) 2000 David E. Young (de.young@computer.org)

;;; This program is free software; you can redistribute it and/or
;;; modify it under the terms of the GNU General Public License
;;; as published by the Free Software Foundation; either version 2
;;; of the License, or (at your option) any later version.

;;; This program is distributed in the hope that it will be useful,
;;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;; GNU General Public License for more details.

;;; You should have received a copy of the GNU General Public License
;;; along with this program; if not, write to the Free Software
;;; Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

;;; File: lisa.zb
;;; Description:  The Zebu grammar for the LISA programming language.
;;;
;;; $Id: lisa.zb,v 1.4 2000/10/17 02:08:22 youngde Exp $

(:name "lisa"
       :domain-file "defrule-domain"
       :grammar "null-grammar"
       :package "LISA"
       :identifier-continue-chars
       "$-_=/<>+*abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890"
       :identifier-start-chars
       "$-_<>=+*/abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
       :lex-cats ((varname
                   "\\?[a-z,A-Z,_]+[a-z,A-Z,0-9,_]*")
                  (anonymous-varname
                   "\\?"))
       )

(defrule defrule
    := ("(" "defrule" name
         comment
         declaration-list
         left-hand-side
         "=>"
         right-hand-side
         ")")
    :build (format t "name: ~S, comment ~S, decls ~S, LHS ~S, RHS ~S~%"
                   name comment declaration-list left-hand-side
                   right-hand-side) 
    )

(defrule comment
    := ()
    := string
    )

(defrule declaration-list
    := ()
    := ("(declare" declaration ")")
    )

(defrule declaration
    := ("(salience" number ")")
    )

(defrule left-hand-side
    := pattern-list
    )

(defrule right-hand-side
    := action-list
    )

(defrule action-list
    := ()
    := (action action-list)
    :build (cons action action-list)
    )

(defrule action
    := sexp
    )

(defrule pattern-list
    := ()

    := (pattern pattern-list)
    :build (cons pattern pattern-list)

    := ("(" variable-name pattern ")" pattern-list)
    :build (list variable-name pattern pattern-list)
    )

(defrule pattern
    := test-pattern
    := ordered-fact
    := unordered-fact
    := (name pattern)
    )

(defrule ordered-fact
    := ("(" name ")")
    :build (list name)
    
    := ("(" name constraint-list ")")
    :build (if (consp constraint-list)
               (cons name constraint-list)
             (list name constraint-list))
    )

(defrule constraint-list
    := constraint
    := (constraint constraint-list)
    :build (cons constraint constraint-list)
    )

(defrule constraint
    := constant

    := (constant constraint-condition)
    :build (list constant constraint-condition)

    := single-field-variable

    := (single-field-variable constraint-condition)
    :build (list single-field-variable constraint-condition)
    )

(defrule constraint-condition
    := sexp
    := constant
    )

(defrule unordered-fact
    := ("(" name slot-list ")")
    :build (cons name slot-list)
    )

(defrule slot-list
    := ()
    := (slot slot-list)
    :build (cons slot slot-list)
    )

(defrule slot
    := ("(" name ")")
    :build (list name)
    
    := ("(" name constraint ")")
    :build (if (consp constraint)
               (cons name constraint)
             (list name constraint))
    )

(defrule test-pattern
    := ("(" "test" sexp ")")
    :build (list "test" sexp)
    )

(defrule sexp
    := ("(" name ")")
    :build (list name)

    := ("(" name lambda-list ")")
    :build (if (consp lambda-list)
               (cons name lambda-list)
             (list name lambda-list))
    )

(defrule lambda-list
    := param

    := (param lambda-list)
    :build (append param lambda-list)

    )

(defrule param
    := constant
    :build (list constant)
    
    := variable-name
    :build (list variable-name)
    
    := sexp
    :build (list sexp)
    )

(defrule single-field-variable
    := variable-name
    := anonymous-variable-name
    )

(defrule variable-name
    := varname

    )

(defrule anonymous-variable-name
    := anonymous-varname
    )

(defrule name
    := identifier
    )

(defrule constant
    := name
    := string
    := number
    )
